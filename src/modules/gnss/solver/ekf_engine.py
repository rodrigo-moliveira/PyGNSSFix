""" Module with the EKF engine for the GNSS PVT estimation. """
import numpy as np

from src.constants import SPEED_OF_LIGHT
from src.data_types.gnss import DataType
from src.errors import SolverError
from src.modules.estimators.EKF import EKF
from src.modules.gnss.solver import PseudorangeReconstructor, CarrierPhaseReconstructor
from src.utils.math_utils import add_state, delete_state


class EKF_Engine:
    """
    Base class for the EKF Engine.

    This class provides a simplified implementation of an Extended Kalman Filter (EKF) for GNSS PVT estimation.
    Unlike traditional EKF designs, this engine does not require the user to provide non-linear state transition
    or observation functions (`f` and `h`). Instead, the state transitions are modelled with
        * random walks
        * white noise
        * ...
    depending on the user configurations. For each case, a different state transition Jacobian (F) is set up.
    Also, depending on the defined states and variables, the observation Jacobian (H) is set up accordingly.

    The full GNSS state vector — including position, velocity, receiver clock bias, and drift — is estimated
    together as a unified block, depending on the user configuration. There are no subclasses derived from this base;
    the state definition is controlled via configuration options.

    The linearized prediction step follows:
        x_pred = F @ x_prev
        P_pred = F @ P_prev @ F.T + Q_d

    The linearized update step uses the innovation vector z (observed minus predicted):
        K = P_pred @ H.T @ (H @ P_pred @ H.T + R)^-1
        x_upd = x_pred + K @ z
        P_upd = P_pred - K @ H @ P_pred

    The `EKF` engine is responsible for constructing the state vector, innovation vector, and corresponding
    Jacobian (F and H), as well as the noise models (Q and R). It then performs a sequential predict-update
    cycle to estimate the GNSS state and update the state-space object
    (:py:class:`src.data_mng.gnss.state_space.GnssStateSpace`).
    """

    def __init__(self, init_state, metadata, trace_data):
        """
        Constructor of the `EKF_Engine` class.

        Args:
            init_state (src.data_mng.gnss.state_space.GnssStateSpace): initial GNSS state vector object
            metadata(dict): dictionary with metadata information about the user configurations and models (generated by
                the :py:class:`src.modules.gnss.solver.gnss_solver.GnssSolver` instance)
            trace_data(tuple or None): path to the trace dir and iteration number
        """
        # internal variables
        self._solver = EKF()
        self._state = init_state
        self._init = False
        self._x = None
        self._P = None
        self._trace_data = trace_data
        self._noise_manager = metadata["ERROR_MODEL"]
        self._prev_sat_list = None

        # scenario configurations
        self.cp_based = metadata["CP_BASED"]
        self.pr_datatypes = metadata["CODES"]
        self.cp_datatypes = metadata["PHASES"]
        self.metadata = metadata

    @property
    def epoch(self):
        """
        Returns:
             src.data_types.date.Epoch : returns the current epoch of the estimation
        """
        return self.state.epoch

    @property
    def state(self):
        """
        Returns:
            src.data_mng.gnss.state_space.GnssStateSpace : returns the current GNSS state instance
        """
        return self._state

    def _build_init_state_cov(self, sat_list) -> tuple[np.ndarray, np.ndarray]:
        """ Initializes the initial state vector and state covariance matrix. """
        slave_constellation = self._state.get_additional_info("clock_slave")
        index_map = self._state.index_map
        n_states = index_map["total_states"]

        P0 = np.zeros((n_states, n_states))
        X0 = np.zeros(n_states)

        # position
        idx_pos = index_map["position"]
        for i in range(3):
            P0[idx_pos + i, idx_pos + i] = self._state.cov_position[idx_pos + i, idx_pos + i]
        X0[idx_pos:idx_pos + 3] = self._state.position

        # clock bias (in meters)
        idx_clock = index_map["clock_bias"]
        P0[idx_clock, idx_clock] = self._state.cov_clock_bias
        X0[idx_clock] = self._state.clock_bias

        # tropo
        if "tropo_wet" in index_map:
            idx_tropo = index_map["tropo_wet"]
            P0[idx_tropo, idx_tropo] = self._state.cov_tropo_wet
            X0[idx_tropo] = self._state.tropo_wet

        # iono
        if "iono" in index_map:
            for sat in sat_list:
                if sat in index_map["iono"]:
                    idx_iono = index_map["iono"][sat]
                    cov_iono = self._state.cov_iono[sat]
                    P0[idx_iono, idx_iono] = cov_iono
                    X0[idx_iono] = self._state.iono[sat]

        # ISB
        if slave_constellation is not None and "isb" in index_map:
            idx_isb = index_map["isb"]
            P0[idx_isb, idx_isb] = self._state.cov_isb
            X0[idx_isb] = self._state.isb

        if "ambiguity" in index_map:
            for sat, cp_types in index_map["ambiguity"].items():
                if self._state.ambiguity.pivot[sat.sat_system] != sat:
                    for cp_type in cp_types:
                        if not self._state.ambiguity[sat][cp_type].fixed:
                            idx_amb = cp_types[cp_type]
                            P0[idx_amb, idx_amb] = self._state.ambiguity[sat][cp_type].cov
                            X0[idx_amb] = self._state.ambiguity[sat][cp_type].val

        if "phase_bias" in index_map:
            for const, cp_types in index_map["phase_bias"].items():
                for cp_type in cp_types:
                    idx_phase_bias = cp_types[cp_type]
                    P0[idx_phase_bias, idx_phase_bias] = self._state.cov_phase_bias[const][cp_type]
                    X0[idx_phase_bias] = self._state.phase_bias[const][cp_type]

        return X0, P0

    def _build_state_cov(self, new_index_map, prev_index_map, sat_list) -> tuple[np.ndarray, np.ndarray]:
        """ Updates the internal state vector and covariance matrix for a change in the GNSS state vector.
        For instance, when a new satellite is introduced or deleted, the size of the state and covariances objects
        (iono or ambiguity variables) must be updated accordingly.
        """
        x_out = self._x
        P_out = self._P

        new_set = set(sat_list)
        prev_set = set(self._prev_sat_list)
        # TODO: what happens when ambiguities are fixed?

        if new_set != prev_set:
            new_sats = new_set - prev_set
            for sat in new_sats:
                # add a new satellite (now in line of sight)
                if "iono" in new_index_map:
                    idx = new_index_map["iono"][sat]
                    x_out, P_out = add_state(x_out, P_out, idx, self.state.iono[sat], self.state.cov_iono[sat])

                if "ambiguity" in new_index_map:
                    if self._state.ambiguity.pivot[sat.sat_system] != sat:
                        cp_types = new_index_map["ambiguity"][sat]
                        for cp_type in cp_types:
                            if not self.state.ambiguity[sat][cp_type].fixed:
                                idx = cp_types[cp_type]
                                x_out, P_out = add_state(x_out, P_out, idx, self.state.ambiguity[sat][cp_type].val,
                                                         self.state.ambiguity[sat][cp_type].cov)

            removed_sats = prev_set - new_set
            idx_to_remove = []
            for sat in removed_sats:

                # update state and cov for removed satellites
                if "iono" in new_index_map:
                    idx = prev_index_map["iono"][sat]
                    idx_to_remove.append(idx)

                if "ambiguity" in new_index_map:
                    if self._state.ambiguity.pivot[sat.sat_system] != sat:
                        cp_types = prev_index_map["ambiguity"][sat]
                        for cp_type in cp_types:
                            # if not self.state.ambiguity[sat][cp_type].fixed:
                            # Nota: este sat já não existe na AmbiguityManager
                            idx = cp_types[cp_type]
                            idx_to_remove.append(idx)
            if len(idx_to_remove) > 0:
                idx_to_remove = sorted(idx_to_remove, reverse=True)
                for idx in idx_to_remove:
                    x_out, P_out = delete_state(x_out, P_out, idx)

        return x_out, P_out

    def _build_stm_process_noise(self, sat_list: list, time_step: float) -> tuple[np.ndarray, np.ndarray]:
        """
        This method builds the State Transition Matrix (STM) and the Process Noise Covariance matrix according to the
        user definitions.
        """
        slave_constellation = self._state.get_additional_info("clock_slave")
        index_map = self._state.index_map
        n_states = index_map["total_states"]

        F = np.zeros((n_states, n_states))  # State Transition Matrix
        Q_d = np.zeros((n_states, n_states))  # Continuous-Time Process Noise Covariance Matrix

        # position
        idx_pos = index_map["position"]
        process_noise = self._noise_manager.position.get_process_noise(time_step)
        for i in range(3):
            Q_d[idx_pos + i, idx_pos + i] = process_noise[i]
            F[idx_pos + i, idx_pos + i] = self._noise_manager.position.get_stm_entry(time_step)

        # clock bias (in meters)
        idx_clock = index_map["clock_bias"]
        Q_d[idx_clock, idx_clock] = self._noise_manager.clock_bias.get_process_noise(time_step) * SPEED_OF_LIGHT**2
        F[idx_clock, idx_clock] = self._noise_manager.clock_bias.get_stm_entry(time_step)

        # tropo
        if "tropo_wet" in index_map:
            idx_tropo = index_map["tropo_wet"]
            Q_d[idx_tropo, idx_tropo] = self._noise_manager.tropo.get_process_noise(time_step)
            F[idx_tropo, idx_tropo] = self._noise_manager.tropo.get_stm_entry(time_step)

        # iono
        if "iono" in index_map:
            for sat in sat_list:
                if sat in index_map["iono"]:
                    idx_iono = index_map["iono"][sat]
                    Q_d[idx_iono, idx_iono] = self._noise_manager.iono.get_process_noise(time_step)
                    F[idx_iono, idx_iono] = self._noise_manager.iono.get_stm_entry(time_step)

        # ISB
        if slave_constellation is not None and "isb" in index_map:
            idx_isb = index_map["isb"]
            Q_d[idx_isb, idx_isb] = self._noise_manager.isb.get_process_noise(time_step) * SPEED_OF_LIGHT**2
            F[idx_isb, idx_isb] = self._noise_manager.isb.get_stm_entry(time_step)

        if "ambiguity" in index_map:
            for sat, cp_types in index_map["ambiguity"].items():
                if self._state.ambiguity.pivot[sat.sat_system] != sat:
                    for cp_type in cp_types:
                        if not self._state.ambiguity[sat][cp_type].fixed:
                            idx_amb = cp_types[cp_type]
                            Q_d[idx_amb, idx_amb] = self._noise_manager.ambiguity.get_process_noise(time_step)
                            F[idx_amb, idx_amb] = self._noise_manager.ambiguity.get_stm_entry(time_step)

        if "phase_bias" in index_map:
            for const, cp_types in index_map["phase_bias"].items():
                for cp_type in cp_types:
                    idx_phase_bias = cp_types[cp_type]
                    Q_d[idx_phase_bias, idx_phase_bias] = self._noise_manager.phase_bias.get_process_noise(time_step) \
                                                          * SPEED_OF_LIGHT**2
                    F[idx_phase_bias, idx_phase_bias] = self._noise_manager.phase_bias.get_stm_entry(time_step)
        return F, Q_d

    @staticmethod
    def compute_residual_los(sat, epoch, datatype, obs_data, reconstructor):
        """
        Computes the prefit residuals (observed minus computed observation) and the line of sight vector w.r.t.
        ECEF frame.

        Args:
            sat(src.data_types.gnss.Satellite): satellite to compute the residual and LOS
            epoch(src.data_types.date.Epoch): epoch to make the computation
            datatype(src.data_types.gnss.DataType): datatype (frequency band) to compute the residual
            obs_data (src.data_mng.gnss.observation_data.EpochData) : instance of `EpochData` (GNSS observable database
                for a single epoch)
            reconstructor (src.modules.gnss.solver.obs_reconstructor.ObservationReconstructor) : reconstructor
                of GNSS measurements (PR, CP or RangeRate)
        """
        # get observable and compute predicted observable
        obs = float(obs_data.get_observable(sat, datatype))

        predicted_obs = reconstructor.compute(sat, epoch, datatype)

        # prefit residuals (observed minus computed)
        prefit_residuals = obs - predicted_obs

        # get LOS vector w.r.t. ECEF frame (column in geometry matrix)
        line_sight = reconstructor.get_unit_line_of_sight(sat)

        return prefit_residuals, line_sight

    def _build_obs_matrix(self, epoch, obs_data, datatypes, state, reconstructor_dict, sat_list) -> \
            tuple[np.ndarray, np.ndarray, np.ndarray]:
        """
        This method builds the observation covariance matrix R, design matrix H and observation residuals y_res
        to be used in the update step of the Kalman Filter
        """
        obs_offset = 0
        index_map = self._state.index_map
        slave_constellation = self._state.get_additional_info("clock_slave")
        n_states = index_map["total_states"]
        n_obs = obs_data.get_number_of_observations(datatypes)

        y_vec = np.zeros(n_obs)
        design_mat = np.zeros((n_obs, n_states))
        R = np.eye(n_obs)

        for const in datatypes.keys():
            for datatype in datatypes[const]:

                if DataType.is_code(datatype):
                    reconstructor = reconstructor_dict["PR"]
                elif DataType.is_carrier(datatype):
                    reconstructor = reconstructor_dict["CP"]
                else:
                    raise SolverError(f"Unknown datatype {datatype} at epoch {epoch}.")

                iSat = 0
                for sat in sat_list:
                    if sat.sat_system != const:
                        continue

                    residual, los = self.compute_residual_los(sat, epoch, datatype, obs_data, reconstructor)

                    # filling the LS matrices
                    y_vec[obs_offset + iSat] = residual

                    # position
                    idx_pos = index_map["position"]
                    design_mat[obs_offset + iSat][idx_pos:idx_pos + 3] = los

                    # clock
                    idx_clock = index_map["clock_bias"]
                    design_mat[obs_offset + iSat, idx_clock] = 1.0

                    # tropo
                    if "tropo_wet" in index_map:
                        map_wet = reconstructor._system_geometry.get("tropo_map_wet", sat)
                        idx_tropo = index_map["tropo_wet"]
                        design_mat[obs_offset + iSat, idx_tropo] = map_wet

                    # iono
                    if "iono" in index_map and sat in index_map["iono"]:
                        factor = (datatypes[const][0].freq.freq_value / datatype.freq.freq_value) ** 2
                        idx_iono = index_map["iono"][sat]
                        if DataType.is_carrier(datatype):
                            design_mat[obs_offset + iSat, idx_iono] = -1.0 * factor  # iono
                        else:
                            design_mat[obs_offset + iSat, idx_iono] = 1.0 * factor  # iono

                    # ISB
                    if "isb" in index_map and sat.sat_system == slave_constellation:
                        idx_isb = index_map["isb"]
                        design_mat[obs_offset + iSat, idx_isb] = 1.0

                    if DataType.is_carrier(datatype):
                        # ambiguity
                        if "ambiguity" in index_map and sat in index_map["ambiguity"]:
                            if self._state.ambiguity.pivot[sat.sat_system] != sat:
                                if not state.ambiguity[sat][datatype].fixed:
                                    idx_amb = index_map["ambiguity"][sat][datatype]
                                    wavelength = SPEED_OF_LIGHT / datatype.freq.freq_value
                                    design_mat[obs_offset + iSat, idx_amb] = wavelength

                        # phase bias
                        if "phase_bias" in index_map and const in index_map["phase_bias"]:
                            idx_phase_bias = index_map["phase_bias"][const][datatype]
                            design_mat[obs_offset + iSat, idx_phase_bias] = 1.0

                    # Weight matrix -> as 1/(obs_std^2)
                    std = reconstructor.get_obs_std(sat, datatype)
                    obs_data.get_observable(sat, datatype).set_std(std)
                    R[obs_offset + iSat, obs_offset + iSat] = std ** 2

                    iSat += 1
                obs_offset += iSat
        return R, design_mat, y_vec

    def _update_state(self, x_out, P_out, sat_list):
        """
        This method updates the internal state vector object (`self._state`) with the estimated state and covariance
        for the current EKF step.
        """
        index_map = self._state.index_map

        # TODO: add ambiguity
        # Perform Ambiguity Resolution (if enabled)
        # if "ambiguity" in index_map and self._state.ambiguity.amb_resolution_enable:
        #    dX, cov = self._state.ambiguity.main_fix(index_map, self._state, dX, cov)
        idx_pos = index_map["position"]
        idx_clock = index_map["clock_bias"]

        self._state.position = x_out[idx_pos:idx_pos + 3]
        self._state.clock_bias = x_out[idx_clock]

        # if iono is estimated
        if "iono" in index_map:
            for sat in sat_list:
                if sat in index_map["iono"]:
                    idx_iono = index_map["iono"][sat]
                    self._state.iono[sat] = x_out[idx_iono]
                    self._state.cov_iono[sat] = P_out[idx_iono, idx_iono]

        # ISB
        if "isb" in index_map:
            idx_isb = index_map["isb"]
            self._state.isb = x_out[idx_isb]
            self._state.cov_isb = P_out[idx_isb, idx_isb]

        # tropo
        if "tropo_wet" in index_map:
            idx_tropo = index_map["tropo_wet"]
            self._state.tropo_wet = x_out[idx_tropo]
            self._state.cov_tropo_wet = P_out[idx_tropo, idx_tropo]

        if "ambiguity" in index_map:
            for sat, cp_types in index_map["ambiguity"].items():
                if self._state.ambiguity.pivot[sat.sat_system] != sat:
                    for cp_type in cp_types:
                        idx_amb = cp_types[cp_type]
                        if not self._state.ambiguity[sat][cp_type].fixed:
                            self._state.ambiguity[sat][cp_type].val = x_out[idx_amb]
                            self._state.ambiguity[sat][cp_type].cov = P_out[idx_amb, idx_amb]

        if "phase_bias" in index_map:
            for const, cp_types in index_map["phase_bias"].items():
                for cp_type in cp_types:
                    idx_phase_bias = cp_types[cp_type]
                    self._state.phase_bias[const][cp_type] = x_out[idx_phase_bias]
                    self._state.cov_phase_bias[const][cp_type] = P_out[idx_phase_bias, idx_phase_bias]

        # unpack covariance matrices
        self._state.cov_position = np.array(P_out[idx_pos:idx_pos + 3, idx_pos:idx_pos + 3])
        self._state.cov_clock_bias = P_out[idx_clock, idx_clock]

    def _build_obs_reconstructor(self, system_geometry) -> tuple[dict, dict]:
        """ Builds the reconstructor and datatypes dictionaries for internal processing procedures. """
        reconstructor = dict()
        reconstructor["PR"] = PseudorangeReconstructor(system_geometry, self.metadata, self._state,
                                                       self._trace_data)

        if self.cp_based:
            datatypes = dict()
            for const in self.pr_datatypes.keys():
                datatypes[const] = dict()
                datatypes[const] = self.pr_datatypes[const] + self.cp_datatypes[const]
            reconstructor["CP"] = CarrierPhaseReconstructor(system_geometry, self.metadata, self._state,
                                                            self._trace_data)
        else:
            datatypes = self.pr_datatypes
        return reconstructor, datatypes

    def estimate(self, epoch, system_geometry, obs_for_epoch):
        """
        Main function of the class. Performs the estimation cycle (predict + update steps) for the provided epoch.

        Args:
            epoch (src.data_types.date.Epoch): current epoch of estimation
            system_geometry (src.data_mng.gnss.geometry.SystemGeometry): instance of `SystemGeometry` to be used in the
                reconstruction models, geometry data for the current estimation state.
            obs_for_epoch (src.data_mng.gnss.observation_data.EpochData) : instance of `EpochData` (GNSS observable
            database for the current epoch).

        TODO:
            add returns and raises
        """
        # TODO: raise SolverError on failure
        reconstructor, datatypes = self._build_obs_reconstructor(system_geometry)
        sat_list = system_geometry.get_satellites()
        time_step = (epoch - self.epoch).total_seconds()

        # prepare state and covariance for the current cycle
        # TODO: move this into a function
        if self._init is False:
            # initialization
            self._state.build_index_map(sat_list)
            x_in, P_in = self._build_init_state_cov(sat_list)
            self._init = True
        else:
            # update the state and covariance for new or deleted states
            prev_index_map = self._state.index_map
            update_pivot = self._state.build_index_map(sat_list)
            if update_pivot:
                x_in, P_in = self._build_init_state_cov(sat_list)
            else:
                new_index_map = self._state.index_map
                x_in, P_in = self._build_state_cov(new_index_map, prev_index_map, sat_list)

        # build state transition matrix and process noise matrices
        F, Q_d = self._build_stm_process_noise(sat_list, time_step)

        # build observation covariance matrix, observation Jacobian and observation residuals
        R, H, residuals_vector = self._build_obs_matrix(epoch, obs_for_epoch, datatypes, self._state,
                                                        reconstructor, sat_list)

        # perform predict step
        x_pred, P_pred = self._solver.predict(x_in, P_in, 0, F, Q_d, continuous=False)

        # perform update step
        x_out, P_out = self._solver.update(residuals_vector, P_pred, x_pred, H, R)

        # update the state vector object with x_out and P_out
        self._update_state(x_out, P_out, sat_list)

        # save internal variables
        self._x = x_out
        self._P = P_out
        self._state.epoch = epoch
        self._prev_sat_list = sat_list

        # build the postfit residuals vector
        post_fit = self.get_postfit_residuals(epoch, obs_for_epoch, datatypes, reconstructor, sat_list)
        norm = np.linalg.norm(post_fit)
        R_inv = np.diag(1.0 / np.diag(R))
        dop_matrix = np.linalg.inv(H.T @ R_inv @ H)

        # build prefit and postfit residual dicts for output
        pre_fit_dict = self.get_residuals(residuals_vector, sat_list, datatypes)
        post_fit_dict = self.get_residuals(post_fit, sat_list, datatypes)
        return pre_fit_dict, post_fit_dict, dop_matrix, norm

    @staticmethod
    def get_residuals(residual_vec, sat_list, datatypes):
        """
        Rearrange the residual vector (from a numpy.ndarray vector) into a more readable format.

        The output is a dictionary keyed by constellation, satellite, and datatype, such that:
            res_dict[constellation][sat][datatype] = residual

        Args:
            residual_vec (numpy.ndarray): The input residual vector to be rearranged.
            sat_list (list): List with available satellites for this epoch
            datatypes(dict): dict with constellations as keys and available datatypes as values

        Returns:
            dict: A dictionary with the rearranged residuals.
        """

        res_dict = dict()
        for const in datatypes.keys():
            n_sats = 0
            for sat in sat_list:
                if sat.sat_system == const:
                    n_sats += 1

            res_dict[const] = dict()
            iSat = 0
            for sat in sat_list:
                if sat.sat_system == const:
                    res_dict[const][sat] = dict()

                    for iFreq, datatype in enumerate(datatypes[const]):
                        res_dict[const][sat][datatype] = residual_vec[iFreq * n_sats + iSat]
                    iSat += 1
        return res_dict

    def get_postfit_residuals(self, epoch, obs_data, datatypes, reconstructor_dict, sat_list):
        obs_offset = 0
        n_obs = obs_data.get_number_of_observations(datatypes)
        postfit_residuals = np.zeros(n_obs)

        for const in datatypes.keys():
            for datatype in datatypes[const]:

                if DataType.is_code(datatype):
                    reconstructor = reconstructor_dict["PR"]
                elif DataType.is_carrier(datatype):
                    reconstructor = reconstructor_dict["CP"]
                else:
                    raise SolverError(f"Unknown datatype {datatype} at epoch {epoch}.")

                iSat = 0
                for sat in sat_list:
                    if sat.sat_system != const:
                        continue

                    r, _ = self.compute_residual_los(sat, epoch, datatype, obs_data, reconstructor)

                    # filling the LS matrices
                    postfit_residuals[obs_offset + iSat] = r
                    iSat += 1
                obs_offset += iSat
        return postfit_residuals

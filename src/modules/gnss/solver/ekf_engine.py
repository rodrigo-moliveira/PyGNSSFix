""" Module with the EKF engine for the GNSS PVT estimation. """
import numpy as np

from src.constants import SPEED_OF_LIGHT
from src.data_types.gnss import DataType
from src.data_types.gnss.data_type import get_base_freq
from src.errors import SolverError
from src.modules.estimators.EKF import EKF
from src.modules.gnss.solver import PseudorangeReconstructor, CarrierPhaseReconstructor, RangeRateReconstructor
from src.utils.math_utils import add_state, delete_state


class EKF_Engine:
    """
    Base class for the EKF Engine.

    This class provides a simplified implementation of an Extended Kalman Filter (EKF) for GNSS PVT estimation.
    Unlike traditional EKF designs, this engine does not require the user to provide non-linear state transition
    or observation functions (`f` and `h`). Instead, the state transitions are modelled with
        * random walks
        * white noise
        * ...
    depending on the user configurations. For each case, a different state transition Jacobian (F) is set up.
    Also, depending on the defined states and variables, the observation Jacobian (H) is set up accordingly.

    The full GNSS state vector — including position, velocity, receiver clock bias, and drift — is estimated
    together as a unified block, depending on the user configuration. There are no subclasses derived from this base;
    the state definition is controlled via configuration options.

    The linearized prediction step follows:
        x_pred = F @ x_prev
        P_pred = F @ P_prev @ F.T + Q_d

    The linearized update step uses the innovation vector z (observed minus predicted):
        K = P_pred @ H.T @ (H @ P_pred @ H.T + R)^-1
        x_upd = x_pred + K @ z
        P_upd = P_pred - K @ H @ P_pred

    The `EKF` engine is responsible for constructing the state vector, innovation vector, and corresponding
    Jacobian (F and H), as well as the noise models (Q and R). It then performs a sequential predict-update
    cycle to estimate the GNSS state and update the state-space object
    (:py:class:`src.data_mng.gnss.state_space.GnssStateSpace`).
    """

    def __init__(self, init_state, metadata, trace_data):
        """
        Constructor of the `EKF_Engine` class.

        Args:
            init_state (src.data_mng.gnss.state_space.GnssStateSpace): initial GNSS state vector object
            metadata(dict): dictionary with metadata information about the user configurations and models (generated by
                the :py:class:`src.modules.gnss.solver.gnss_solver.GnssSolver` instance)
            trace_data(tuple or None): path to the trace dir and iteration number
        """
        # internal variables
        self._solver = EKF()
        self._state = init_state
        self._init = False
        self._x = None
        self._P = None
        self._trace_data = trace_data
        self._noise_manager = metadata["ERROR_MODEL"]
        self._prev_sat_list = None
        self._amb_fixed = False

        # scenario configurations
        self.cp_based = metadata["CP_BASED"]
        self.pr_datatypes = metadata["CODES"]
        self.cp_datatypes = metadata["PHASES"]
        self.metadata = metadata
        self.estimate_vel = metadata["VELOCITY_EST"]
        self.rr_datatypes = None
        if self.estimate_vel:
            self.rr_datatypes = metadata["DOPPLER"]

    @property
    def epoch(self):
        """
        Returns:
             src.data_types.date.Epoch : returns the current epoch of the estimation
        """
        return self.state.epoch

    @property
    def state(self):
        """
        Returns:
            src.data_mng.gnss.state_space.GnssStateSpace : returns the current GNSS state instance
        """
        return self._state

    def _build_init_state_cov(self, sat_list) -> tuple[np.ndarray, np.ndarray]:
        """ Initializes the initial state vector and state covariance matrix. """
        slave_constellation = self._state.get_additional_info("clock_slave")
        index_map = self._state.index_map
        n_states = index_map["total_states"]

        P0 = np.zeros((n_states, n_states))
        X0 = np.zeros(n_states)

        # position
        idx_pos = index_map["position"]
        for i in range(3):
            P0[idx_pos + i, idx_pos + i] = self._state.cov_position[i, i]
        X0[idx_pos:idx_pos + 3] = self._state.position

        # clock bias (in meters)
        idx_clock = index_map["clock_bias"]
        P0[idx_clock, idx_clock] = self._state.cov_clock_bias
        X0[idx_clock] = self._state.clock_bias

        # tropo
        if "tropo_wet" in index_map:
            idx_tropo = index_map["tropo_wet"]
            P0[idx_tropo, idx_tropo] = self._state.cov_tropo_wet
            X0[idx_tropo] = self._state.tropo_wet

        # iono
        if "iono" in index_map:
            for sat in sat_list:
                if sat in index_map["iono"]:
                    idx_iono = index_map["iono"][sat]
                    cov_iono = self._state.cov_iono[sat]
                    P0[idx_iono, idx_iono] = cov_iono
                    X0[idx_iono] = self._state.iono[sat]

        # ISB
        if slave_constellation is not None and "isb" in index_map:
            idx_isb = index_map["isb"]
            P0[idx_isb, idx_isb] = self._state.cov_isb
            X0[idx_isb] = self._state.isb

        if "ambiguity" in index_map:
            for sat, cp_types in index_map["ambiguity"].items():
                if self._state.ambiguity.pivot[sat.sat_system] != sat:
                    for cp_type in cp_types:
                        if not self._state.ambiguity[sat][cp_type].fixed:
                            idx_amb = cp_types[cp_type]
                            P0[idx_amb, idx_amb] = self._state.ambiguity[sat][cp_type].cov
                            X0[idx_amb] = self._state.ambiguity[sat][cp_type].val

        if "phase_bias" in index_map:
            for const, cp_types in index_map["phase_bias"].items():
                for cp_type in cp_types:
                    idx_phase_bias = cp_types[cp_type]
                    P0[idx_phase_bias, idx_phase_bias] = self._state.cov_phase_bias[const][cp_type]
                    X0[idx_phase_bias] = self._state.phase_bias[const][cp_type]

        if "velocity" in index_map:
            idx_vel = index_map["velocity"]
            for i in range(3):
                P0[idx_vel + i, idx_vel + i] = self._state.cov_velocity[i, i]
            X0[idx_vel:idx_vel + 3] = self._state.velocity

        if "clock_bias_rate" in index_map:
            # clock bias rate (in m/s)
            for const, idx_clock_rate in index_map["clock_bias_rate"].items():
                P0[idx_clock_rate, idx_clock_rate] = self._state.cov_clock_bias_rate[const]
                X0[idx_clock_rate] = self._state.clock_bias_rate[const]

        return X0, P0

    def _build_state_cov(self, new_index_map, prev_index_map, epoch) -> tuple[np.ndarray, np.ndarray]:
        """ Updates the internal state vector and covariance matrix for a change in the GNSS state vector.
        For instance, when a new satellite is introduced or deleted, the size of the state and covariances objects
        (iono or ambiguity variables) must be updated accordingly.
        """
        x_out = self._x
        P_out = self._P

        if new_index_map != prev_index_map:
            # Update satellite-based states
            idx_to_remove = []
            new_states = {}

            # first, check what are the indexes to be removed
            if "iono" in new_index_map:
                removed_sats = set(prev_index_map["iono"].keys()) - set(new_index_map["iono"].keys())
                for sat in removed_sats:
                    idx = prev_index_map["iono"][sat]
                    idx_to_remove.append(idx)
            if "ambiguity" in new_index_map:
                removed_sats = set(prev_index_map["ambiguity"].keys()) - set(new_index_map["ambiguity"].keys())
                for sat in removed_sats:
                    cp_types = prev_index_map["ambiguity"][sat]
                    for cp_type in cp_types:
                        idx = cp_types[cp_type]
                        idx_to_remove.append(idx)
            # then, update state and cov for removed satellites
            if len(idx_to_remove) > 0:
                # remove from highest to lowest index
                idx_to_remove = sorted(idx_to_remove, reverse=True)
                for idx in idx_to_remove:
                    x_out, P_out = delete_state(x_out, P_out, idx)

            # after removing all previous states, check what are the new state indexes
            if "iono" in new_index_map:
                new_sats = set(new_index_map["iono"].keys()) - set(prev_index_map["iono"].keys())
                for sat in new_sats:
                    idx = new_index_map["iono"][sat]
                    new_states[idx] = ("iono", sat)
            if "ambiguity" in new_index_map:
                new_sats = set(new_index_map["ambiguity"].keys()) - set(prev_index_map["ambiguity"].keys())
                for sat in new_sats:
                    if self._state.ambiguity.pivot[sat.sat_system] != sat:
                        cp_types = new_index_map["ambiguity"][sat]
                        for cp_type in cp_types:
                            if not self.state.ambiguity[sat][cp_type].fixed:
                                idx = cp_types[cp_type]
                                new_states[idx] = ("ambiguity", sat, cp_type)

            # finally, insert the new states to the state vector and covariance matrix
            idx_to_add = list(new_states.keys())
            if len(idx_to_add) > 0:
                idx_to_add = sorted(idx_to_add)
                for idx in idx_to_add:
                    args = new_states[idx]
                    if args[0] == "iono":
                        rel_increase = self._noise_manager.iono.relative_re_param
                        x_out, P_out = add_state(x_out, P_out, idx, self.state.iono[args[1]],
                                                 self.state.cov_iono[args[1]] * rel_increase)
                    elif args[0] == "ambiguity":
                        rel_increase = self._noise_manager.ambiguity.relative_re_param
                        x_out, P_out = add_state(x_out, P_out, idx, self.state.ambiguity[args[1]][args[2]].val,
                                                 self.state.ambiguity[args[1]][args[2]].cov * rel_increase)

        # check for cycle slips
        if "ambiguity" in new_index_map:
            x_out, P_out = self._check_cycle_slips(epoch, new_index_map, x_out, P_out)

        return x_out, P_out

    def _check_cycle_slips(self, epoch, index_map, x, P) -> tuple[np.ndarray, np.ndarray]:
        """ Checks if there was any detected cycle slip for this epoch and updates the ambiguity states accordingly. """
        sat_list = self._state.ambiguity.check_cycle_slips(epoch)
        for sat in sat_list:
            # update ambiguity states and covariances for the detected cycle slip ambiguity
            if self._state.ambiguity.pivot[sat.sat_system] != sat:
                cp_types = index_map["ambiguity"][sat]
                for cp_type in cp_types:
                    idx_amb = cp_types[cp_type]
                    P[:, idx_amb] = 0
                    P[idx_amb, :] = 0
                    P[idx_amb, idx_amb] = self._state.ambiguity[sat][cp_type].cov
                    x[idx_amb] = self._state.ambiguity[sat][cp_type].val

        return x, P

    def _relax_cov_pivot_change(self, x_in, P_in):
        """
        When there is a change in pivot, all the other states get affected. This function increases their covariance
        to allow a better re-convergence of the cross-affected states.
        """
        index_map = self._state.index_map
        P_out = P_in.copy()
        x_out = x_in.copy()

        # update ambiguity states and covariances
        if "ambiguity" in index_map:
            for sat, cp_types in index_map["ambiguity"].items():
                if self._state.ambiguity.pivot[sat.sat_system] != sat:
                    for cp_type in cp_types:
                        idx_amb = cp_types[cp_type]
                        P_out[:, idx_amb] = 0
                        P_out[idx_amb, :] = 0
                        P_out[idx_amb, idx_amb] = self._state.ambiguity[sat][cp_type].cov
                        x_out[idx_amb] = self._state.ambiguity[sat][cp_type].val

        # position
        idx_pos = index_map["position"]
        relative_re_param = self._noise_manager.position.relative_re_param
        for i in range(3):
            P_out[idx_pos + i, idx_pos + i] = P_in[idx_pos + i, idx_pos + i] * relative_re_param

        # clock bias (in meters)
        idx_clock = index_map["clock_bias"]
        relative_re_param = self._noise_manager.clock_bias.relative_re_param
        P_out[idx_clock, idx_clock] = P_in[idx_clock, idx_clock] * relative_re_param

        # tropo
        if "tropo_wet" in index_map:
            idx_tropo = index_map["tropo_wet"]
            relative_re_param = self._noise_manager.tropo.relative_re_param
            P_out[idx_tropo, idx_tropo] = P_in[idx_tropo, idx_tropo] * relative_re_param

        # iono
        if "iono" in index_map:
            for sat in index_map["iono"].keys():
                idx_iono = index_map["iono"][sat]
                relative_re_param = self._noise_manager.iono.relative_re_param
                P_out[idx_iono, idx_iono] = P_in[idx_iono, idx_iono] * relative_re_param

        # ISB
        if "isb" in index_map:
            idx_isb = index_map["isb"]
            relative_re_param = self._noise_manager.isb.relative_re_param
            P_out[idx_isb, idx_isb] = P_in[idx_isb, idx_isb] * relative_re_param

        # Phase Bias
        if "phase_bias" in index_map:
            relative_re_param = self._noise_manager.phase_bias.relative_re_param
            for const, cp_types in index_map["phase_bias"].items():
                for cp_type in cp_types:
                    idx_phase_bias = cp_types[cp_type]
                    P_out[idx_phase_bias, idx_phase_bias] = P_in[idx_phase_bias, idx_phase_bias] * relative_re_param

        if "velocity" in index_map:
            idx_vel = index_map["velocity"]
            relative_re_param = self._noise_manager.velocity.relative_re_param
            for i in range(3):
                P_out[idx_vel + i, idx_vel + i] = P_in[idx_vel + i, idx_vel + i] * relative_re_param

        if "clock_bias_rate" in index_map:
            relative_re_param = self._noise_manager.clock_drift.relative_re_param
            for const, idx_clock_rate in index_map["clock_bias_rate"].items():
                P_out[idx_clock_rate, idx_clock_rate] = P_in[idx_clock_rate, idx_clock_rate] * relative_re_param

        return x_out, P_out

    def _build_stm_process_noise(self, sat_list: list, time_step: float) -> tuple[np.ndarray, np.ndarray]:
        """
        This method builds the State Transition Matrix (STM) and the Process Noise Covariance matrix according to the
        user definitions.
        """
        PV_Model = self.metadata.get("ERROR_MODEL").b_pv_model
        Clock_Model = self.metadata.get("ERROR_MODEL").b_clock_model
        slave_constellation = self._state.get_additional_info("clock_slave")
        index_map = self._state.index_map
        n_states = index_map["total_states"]

        F = np.zeros((n_states, n_states))  # State Transition Matrix
        Q_d = np.zeros((n_states, n_states))  # Discrete-Time Process Noise Covariance Matrix

        if PV_Model and "velocity" in index_map:
            # Apply PV Model (pos-vel correlated)
            idx_pos = index_map["position"]
            idx_vel = index_map["velocity"]
            pos_noise = self._noise_manager.position.get_process_noise(time_step)  # in m^2
            vel_noise = self._noise_manager.velocity.get_process_noise(time_step)  # in m^2/s^2
            stm_pos = self._noise_manager.position.get_stm_entry(time_step)
            stm_vel = self._noise_manager.velocity.get_stm_entry(time_step)

            Q_d[idx_pos:idx_pos + 3, idx_pos:idx_pos + 3] = np.eye(3) * (pos_noise + vel_noise*time_step**2/3)
            Q_d[idx_pos:idx_pos + 3, idx_vel:idx_vel + 3] = np.eye(3) * (vel_noise * time_step / 2)
            Q_d[idx_vel:idx_vel + 3, idx_pos:idx_pos + 3] = np.eye(3) * (vel_noise * time_step / 2)
            Q_d[idx_vel:idx_vel + 3, idx_vel:idx_vel + 3] = np.eye(3) * vel_noise

            F[idx_pos:idx_pos + 3, idx_pos:idx_pos + 3] = np.eye(3) * stm_pos
            F[idx_vel:idx_vel + 3, idx_vel:idx_vel + 3] = np.eye(3) * stm_vel
            F[idx_pos:idx_pos + 3, idx_vel:idx_vel + 3] = np.eye(3) * time_step

        else:
            # apply uncorrelated position and velocity states
            # position (m)
            idx_pos = index_map["position"]
            process_noise = self._noise_manager.position.get_process_noise(time_step)
            Q_d[idx_pos:idx_pos+3, idx_pos:idx_pos+3] = np.eye(3) * process_noise
            F[idx_pos:idx_pos + 3, idx_pos:idx_pos + 3] = np.eye(3) * self._noise_manager.position.get_stm_entry(
                time_step)

            # velocity (m/s)
            if "velocity" in index_map:
                idx_vel = index_map["velocity"]
                process_noise = self._noise_manager.velocity.get_process_noise(time_step)

                Q_d[idx_vel:idx_vel + 3, idx_vel:idx_vel + 3] = np.eye(3) * process_noise
                F[idx_vel:idx_vel + 3, idx_vel:idx_vel + 3] = np.eye(3) * self._noise_manager.velocity.get_stm_entry(
                    time_step)

        if Clock_Model and "clock_bias_rate" in index_map:
            # Apply Clock Model (clock bias and drift correlated)
            idx_clock = index_map["clock_bias"]
            master_constellation = self._state.get_additional_info("clock_master")
            idx_clock_rate_master = index_map["clock_bias_rate"][master_constellation]
            clock_noise = self._noise_manager.clock_bias.get_process_noise(time_step) * SPEED_OF_LIGHT ** 2
            drift_noise = self._noise_manager.clock_drift.get_process_noise(time_step) * SPEED_OF_LIGHT ** 2
            stm_bias = self._noise_manager.clock_bias.get_stm_entry(time_step)
            stm_drift = self._noise_manager.clock_drift.get_stm_entry(time_step)

            # master clock bias model
            Q_d[idx_clock, idx_clock] = clock_noise + drift_noise * time_step ** 2 / 3
            Q_d[idx_clock, idx_clock_rate_master] = drift_noise * time_step / 2
            Q_d[idx_clock_rate_master, idx_clock] = drift_noise * time_step / 2
            Q_d[idx_clock_rate_master, idx_clock_rate_master] = drift_noise

            F[idx_clock, idx_clock] = stm_bias
            F[idx_clock_rate_master, idx_clock_rate_master] = stm_drift
            F[idx_clock, idx_clock_rate_master] = time_step

            # slave clock bias drift (uncorrelated)
            for const, idx_clock_rate in index_map["clock_bias_rate"].items():
                if const == master_constellation:
                    continue
                Q_d[idx_clock_rate, idx_clock_rate] = drift_noise
                F[idx_clock_rate, idx_clock_rate] = self._noise_manager.clock_drift.get_stm_entry(time_step)

        else:
            # clock bias (in meters)
            idx_clock = index_map["clock_bias"]
            Q_d[idx_clock, idx_clock] = self._noise_manager.clock_bias.get_process_noise(
                time_step) * SPEED_OF_LIGHT ** 2
            F[idx_clock, idx_clock] = self._noise_manager.clock_bias.get_stm_entry(time_step)

            # clock bias rate (m/s)
            if "clock_bias_rate" in index_map:
                for const, idx_clock_rate in index_map["clock_bias_rate"].items():
                    Q_d[idx_clock_rate, idx_clock_rate] = self._noise_manager.clock_drift.get_process_noise(
                        time_step) * SPEED_OF_LIGHT ** 2
                    F[idx_clock_rate, idx_clock_rate] = self._noise_manager.clock_drift.get_stm_entry(time_step)

        # tropo (m)
        if "tropo_wet" in index_map:
            idx_tropo = index_map["tropo_wet"]
            Q_d[idx_tropo, idx_tropo] = self._noise_manager.tropo.get_process_noise(time_step)
            F[idx_tropo, idx_tropo] = self._noise_manager.tropo.get_stm_entry(time_step)

        # iono (m)
        if "iono" in index_map:
            for sat in sat_list:
                if sat in index_map["iono"]:
                    idx_iono = index_map["iono"][sat]
                    Q_d[idx_iono, idx_iono] = self._noise_manager.iono.get_process_noise(time_step)
                    F[idx_iono, idx_iono] = self._noise_manager.iono.get_stm_entry(time_step)

        # ISB (m)
        if slave_constellation is not None and "isb" in index_map:
            idx_isb = index_map["isb"]
            Q_d[idx_isb, idx_isb] = self._noise_manager.isb.get_process_noise(time_step) * SPEED_OF_LIGHT ** 2
            F[idx_isb, idx_isb] = self._noise_manager.isb.get_stm_entry(time_step)

        # ambiguity (cycles)
        if "ambiguity" in index_map:
            for sat, cp_types in index_map["ambiguity"].items():
                if self._state.ambiguity.pivot[sat.sat_system] != sat:
                    for cp_type in cp_types:
                        if not self._state.ambiguity[sat][cp_type].fixed:
                            idx_amb = cp_types[cp_type]
                            Q_d[idx_amb, idx_amb] = self._noise_manager.ambiguity.get_process_noise(time_step)
                            F[idx_amb, idx_amb] = self._noise_manager.ambiguity.get_stm_entry(time_step)

        # phase bias (m)
        if "phase_bias" in index_map:
            for const, cp_types in index_map["phase_bias"].items():
                for cp_type in cp_types:
                    idx_phase_bias = cp_types[cp_type]
                    Q_d[idx_phase_bias, idx_phase_bias] = self._noise_manager.phase_bias.get_process_noise(time_step) \
                                                          * SPEED_OF_LIGHT ** 2
                    F[idx_phase_bias, idx_phase_bias] = self._noise_manager.phase_bias.get_stm_entry(time_step)

        return F, Q_d

    @staticmethod
    def compute_residual_los(sat, epoch, datatype, obs_data, reconstructor):
        """
        Computes the prefit residuals (observed minus computed observation) and the line of sight vector w.r.t.
        ECEF frame for the pseudorange / carrier phase measurements

        Args:
            sat(src.data_types.gnss.Satellite): satellite to compute the residual and LOS
            epoch(src.data_types.date.Epoch): epoch to make the computation
            datatype(src.data_types.gnss.DataType): datatype (frequency band) to compute the residual
            obs_data (src.data_mng.gnss.observation_data.EpochData) : instance of `EpochData` (GNSS observable database
                for a single epoch)
            reconstructor (src.modules.gnss.solver.obs_reconstructor.ObservationReconstructor) : reconstructor
                of GNSS measurements (PR, CP)
        """
        # get observable and compute predicted observable
        obs = float(obs_data.get_observable(sat, datatype))

        predicted_obs = reconstructor.compute(sat, epoch, datatype)

        # prefit residuals (observed minus computed)
        prefit_residuals = obs - predicted_obs

        # get LOS vector w.r.t. ECEF frame (column in geometry matrix)
        line_sight = reconstructor.get_unit_line_of_sight(sat)

        return prefit_residuals, line_sight

    @staticmethod
    def compute_residual_los_rr(sat, epoch, datatype, obs_data, reconstructor):
        """
        Computes the prefit residuals (observed minus computed observation) and the line of sight vector w.r.t.
        ECEF frame for the range rate measurements

        Args:
            sat(src.data_types.gnss.Satellite): satellite to compute the residual and LOS
            epoch(src.data_types.date.Epoch): epoch to make the computation
            datatype(src.data_types.gnss.DataType): datatype (frequency band) to compute the residual
            obs_data (src.data_mng.gnss.observation_data.EpochData) : instance of `EpochData` (GNSS observable database
                for a single epoch)
            reconstructor (src.modules.gnss.solver.obs_reconstructor.ObservationReconstructor) : reconstructor
                of GNSS measurements (RangeRate)
        """

        # get observable and compute predicted observable
        obs = float(obs_data.get_observable(sat, datatype))  # in Hz

        # transform Doppler to pseudorange rate
        wavelength = SPEED_OF_LIGHT / datatype.freq_value  # in meters
        obs_range_rate = -wavelength * obs  # in m/s

        predicted_obs = reconstructor.compute(sat, epoch, datatype)

        # prefit residuals (observed minus computed)
        prefit_residuals = obs_range_rate - predicted_obs

        los = -reconstructor.get_unit_line_of_sight(sat)

        return prefit_residuals, los

    def _build_obs_matrix_rr(self, obs_offset, sat_list, epoch, datatype, obs_data, reconstructor,
                                y_vec, R, design_mat):
        """
        This method builds the observation covariance matrix R, design matrix H and observation residuals y_vec
        for the range rate measurements.
        """
        index_map = self._state.index_map
        const = datatype.constellation

        iSat = 0
        for sat in sat_list:
            if sat.sat_system != const:
                continue

            residual, los = self.compute_residual_los_rr(sat, epoch, datatype, obs_data, reconstructor)

            # filling the LS matrices
            y_vec[obs_offset + iSat] = residual

            # velocity
            idx_vel = index_map["velocity"]
            design_mat[obs_offset + iSat][idx_vel:idx_vel + 3] = -los

            # clock
            idx_clock = index_map["clock_bias_rate"][sat.sat_system]
            design_mat[obs_offset + iSat, idx_clock] = 1.0

            # Weight matrix -> as 1/(obs_std^2)
            std = reconstructor.get_obs_std(sat, datatype)
            obs_data.get_observable(sat, datatype).set_std(std)
            R[obs_offset + iSat, obs_offset + iSat] = std ** 2

            iSat += 1

        obs_offset += iSat
        return obs_offset

    def _build_obs_matrix_pr_cp(self, obs_offset, sat_list, epoch, datatype, obs_data, reconstructor,
                                y_vec, R, design_mat):
        """
        This method builds the observation covariance matrix R, design matrix H and observation residuals y_vec
        for the pseudorange and carrier phase measurements.
        """

        slave_constellation = self._state.get_additional_info("clock_slave")
        index_map = self._state.index_map
        const = datatype.constellation

        iSat = 0
        for sat in sat_list:
            if sat.sat_system != const:
                continue

            residual, los = self.compute_residual_los(sat, epoch, datatype, obs_data, reconstructor)

            # filling the LS matrices
            y_vec[obs_offset + iSat] = residual

            # position
            idx_pos = index_map["position"]
            design_mat[obs_offset + iSat][idx_pos:idx_pos + 3] = los

            # clock
            idx_clock = index_map["clock_bias"]
            design_mat[obs_offset + iSat, idx_clock] = 1.0

            # tropo
            if "tropo_wet" in index_map:
                map_wet = reconstructor._system_geometry.get("tropo_map_wet", sat)
                idx_tropo = index_map["tropo_wet"]
                design_mat[obs_offset + iSat, idx_tropo] = map_wet

            # iono
            if "iono" in index_map and sat in index_map["iono"]:
                # factor = (datatypes[const][0].freq.freq_value / datatype.freq.freq_value) ** 2
                factor = (get_base_freq(const).freq_value / datatype.freq.freq_value) ** 2
                idx_iono = index_map["iono"][sat]
                if DataType.is_carrier(datatype):
                    design_mat[obs_offset + iSat, idx_iono] = -1.0 * factor  # iono
                else:
                    design_mat[obs_offset + iSat, idx_iono] = 1.0 * factor  # iono

            # ISB
            if "isb" in index_map and sat.sat_system == slave_constellation:
                idx_isb = index_map["isb"]
                design_mat[obs_offset + iSat, idx_isb] = 1.0

            if DataType.is_carrier(datatype):
                # ambiguity
                if "ambiguity" in index_map and sat in index_map["ambiguity"]:
                    if self._state.ambiguity.pivot[sat.sat_system] != sat:
                        if not self._state.ambiguity[sat][datatype].fixed:
                            idx_amb = index_map["ambiguity"][sat][datatype]
                            wavelength = SPEED_OF_LIGHT / datatype.freq.freq_value
                            design_mat[obs_offset + iSat, idx_amb] = wavelength

                # phase bias
                if "phase_bias" in index_map and const in index_map["phase_bias"]:
                    idx_phase_bias = index_map["phase_bias"][const][datatype]
                    design_mat[obs_offset + iSat, idx_phase_bias] = 1.0

            # Weight matrix -> as 1/(obs_std^2)
            std = reconstructor.get_obs_std(sat, datatype)
            obs_data.get_observable(sat, datatype).set_std(std)
            R[obs_offset + iSat, obs_offset + iSat] = std ** 2

            iSat += 1
        obs_offset += iSat
        return obs_offset

    def _build_obs_matrix(self, epoch, pr_cp_obs_data, rr_obs_data, datatypes, reconstructor_dict,
                          sat_list) -> tuple[np.ndarray, np.ndarray, np.ndarray]:
        """
        This method builds the observation covariance matrix R, design matrix H and observation residuals y_res
        to be used in the update step of the Kalman Filter
        """
        obs_offset = 0
        index_map = self._state.index_map

        n_states = index_map["total_states"]
        n_obs_pr_cp = pr_cp_obs_data.get_number_of_pr_cp_observations(datatypes)
        n_obs_rr = rr_obs_data.get_number_of_doppler_observations(datatypes)
        n_obs = n_obs_pr_cp + n_obs_rr

        y_vec = np.zeros(n_obs)
        design_mat = np.zeros((n_obs, n_states))
        R = np.eye(n_obs)

        for const in datatypes.keys():
            for datatype in datatypes[const]:

                if DataType.is_code(datatype):
                    reconstructor = reconstructor_dict["PR"]
                elif DataType.is_carrier(datatype):
                    reconstructor = reconstructor_dict["CP"]
                elif DataType.is_doppler(datatype):
                    reconstructor = reconstructor_dict["RR"]
                else:
                    raise SolverError(f"Unknown datatype {datatype} at epoch {epoch}.")

                if DataType.is_code(datatype) or DataType.is_carrier(datatype):
                    obs_offset = self._build_obs_matrix_pr_cp(obs_offset, sat_list, epoch, datatype, pr_cp_obs_data,
                                                              reconstructor, y_vec, R, design_mat)
                elif DataType.is_doppler(datatype):
                    obs_offset = self._build_obs_matrix_rr(obs_offset, sat_list, epoch, datatype, rr_obs_data,
                                                              reconstructor, y_vec, R, design_mat)

        return R, design_mat, y_vec

    def _update_state(self, x_out, P_out, sat_list):
        """
        This method updates the internal state vector object (`self._state`) with the estimated state and covariance
        for the current EKF step.
        """
        index_map = self._state.index_map

        # Perform Ambiguity Resolution (if enabled)
        if "ambiguity" in index_map and self._state.ambiguity.amb_resolution_enable:
            x_out, P_out, amb_fixed = self._state.ambiguity.main_fix(index_map, x_out, P_out, state_type="full")
            # flag the filter that at least one ambiguity was successfully fixed
            self._amb_fixed = amb_fixed

        idx_pos = index_map["position"]
        idx_clock = index_map["clock_bias"]

        self._state.position = x_out[idx_pos:idx_pos + 3]
        self._state.clock_bias = x_out[idx_clock]

        # if iono is estimated
        if "iono" in index_map:
            for sat in sat_list:
                if sat in index_map["iono"]:
                    idx_iono = index_map["iono"][sat]
                    self._state.iono[sat] = x_out[idx_iono]
                    self._state.cov_iono[sat] = P_out[idx_iono, idx_iono]

        # ISB
        if "isb" in index_map:
            idx_isb = index_map["isb"]
            self._state.isb = x_out[idx_isb]
            self._state.cov_isb = P_out[idx_isb, idx_isb]

        # tropo
        if "tropo_wet" in index_map:
            idx_tropo = index_map["tropo_wet"]
            self._state.tropo_wet = x_out[idx_tropo]
            self._state.cov_tropo_wet = P_out[idx_tropo, idx_tropo]

        if "ambiguity" in index_map:
            for sat, cp_types in index_map["ambiguity"].items():
                if self._state.ambiguity.pivot[sat.sat_system] != sat:
                    for cp_type in cp_types:
                        idx_amb = cp_types[cp_type]
                        if not self._state.ambiguity[sat][cp_type].fixed:
                            self._state.ambiguity[sat][cp_type].val = x_out[idx_amb]
                            self._state.ambiguity[sat][cp_type].cov = P_out[idx_amb, idx_amb]

        if "phase_bias" in index_map:
            for const, cp_types in index_map["phase_bias"].items():
                for cp_type in cp_types:
                    idx_phase_bias = cp_types[cp_type]
                    self._state.phase_bias[const][cp_type] = x_out[idx_phase_bias]
                    self._state.cov_phase_bias[const][cp_type] = P_out[idx_phase_bias, idx_phase_bias]

        if "velocity" in index_map:
            idx_vel = index_map["velocity"]
            # velocity with respect to ECEF frame
            vel = x_out[idx_vel:idx_vel + 3]
            self._state.velocity = vel  # in [m/s]
            self._state.cov_velocity = np.array(P_out[idx_vel:idx_vel + 3, idx_vel:idx_vel + 3])

        if "clock_bias_rate" in index_map:
            for const, idx_clock_rate in index_map["clock_bias_rate"].items():
                # receiver clock drift [m/m]
                self._state.clock_bias_rate[const] = x_out[idx_clock_rate]
                self._state.cov_clock_bias_rate[const] = float(P_out[idx_clock_rate, idx_clock_rate])

        # unpack covariance matrices
        self._state.cov_position = np.array(P_out[idx_pos:idx_pos + 3, idx_pos:idx_pos + 3])
        self._state.cov_clock_bias = P_out[idx_clock, idx_clock]

        return x_out, P_out

    def _build_obs_reconstructor(self, system_geometry) -> tuple[dict, dict]:
        """ Builds the reconstructor and datatypes dictionaries for internal processing procedures. """
        reconstructor = dict()
        reconstructor["PR"] = PseudorangeReconstructor(system_geometry, self.metadata, self._state,
                                                       self._trace_data)

        if self.cp_based:
            datatypes = dict()
            for const in self.pr_datatypes.keys():
                datatypes[const] = list()
                datatypes[const] = self.pr_datatypes[const] + self.cp_datatypes[const]
            reconstructor["CP"] = CarrierPhaseReconstructor(system_geometry, self.metadata, self._state,
                                                            self._trace_data)
        else:
            datatypes = self.pr_datatypes.copy()

        if self.estimate_vel:
            for const in self.rr_datatypes.keys():
                datatypes[const] = datatypes[const] + self.rr_datatypes[const].copy()
            reconstructor["RR"] = RangeRateReconstructor(system_geometry, self.metadata, self._state,
                                                         self._trace_data)

        return reconstructor, datatypes

    def _init_states(self, sat_list, epoch):
        """ Manages the initialization of state and covariance for the current epoch.
        Fetches the state and covariance from the initialization data or from the previous epoch.
        """
        if self._init is False:
            # initialization
            self._state.build_index_map(sat_list)
            x_in, P_in = self._build_init_state_cov(sat_list)
            self._init = True
        else:
            # update the state and covariance for new or deleted states
            prev_index_map = self._state.index_map
            update_pivot = self._state.build_index_map(sat_list, amb_fixed=self._amb_fixed)
            self._amb_fixed = False
            new_index_map = self._state.index_map
            x_in, P_in = self._build_state_cov(new_index_map, prev_index_map, epoch)
            if update_pivot:
                x_in, P_in = self._relax_cov_pivot_change(x_in, P_in)
        return x_in, P_in

    def estimate(self, epoch, system_geometry, pr_cp_obs_for_epoch, rr_obs_for_epoch):
        """
        Main function of the class. Performs the estimation cycle (predict + update steps) for the provided epoch.

        Args:
            epoch (src.data_types.date.Epoch): current epoch of estimation
            system_geometry (src.data_mng.gnss.geometry.SystemGeometry): instance of `SystemGeometry` to be used in the
                reconstruction models, geometry data for the current estimation state.
            pr_cp_obs_for_epoch (src.data_mng.gnss.observation_data.EpochData) : instance of `EpochData` (GNSS
                observable database for the current epoch containing Pseudorange and Carrier phase measurements).
            rr_obs_for_epoch (src.data_mng.gnss.observation_data.EpochData) : instance of `EpochData` (GNSS
                observable database for the current epoch containing Range Rate measurements).

        Returns:
            tuple[dict, dict, numpy.ndarray, float]:
                * first element is a dict with the prefit residuals (indexed by constellation, satellite and datatype)
                * second element is a dict with the postfit residuals (indexed by constellation, satellite and datatype)
                * third element is a numpy array object with the DOP matrix, DOP = (G.T * G)^-1
                * fourth element is the norm of the postfit residuals vector

        Raises:
            SolverError: an exception is raised if the EKF problem fails to be solved for this epoch
        """
        try:
            reconstructor, datatypes = self._build_obs_reconstructor(system_geometry)
            sat_list = system_geometry.get_satellites()
            time_step = (epoch - self.epoch).total_seconds()

            # prepare state and covariance for the current cycle
            x_in, P_in = self._init_states(sat_list, epoch)

            # build state transition matrix and process noise matrices
            F, Q_d = self._build_stm_process_noise(sat_list, time_step)

            # build observation covariance matrix, observation Jacobian and observation residuals
            R, H, residuals_vector = self._build_obs_matrix(epoch, pr_cp_obs_for_epoch, rr_obs_for_epoch, datatypes,
                                                            reconstructor, sat_list)

            # perform predict step
            x_pred, P_pred = self._solver.predict(x_in, P_in, 0, F, Q_d, continuous=False)

            # perform update step
            x_out, P_out = self._solver.update(residuals_vector, P_pred, x_pred, H, R)

            # update the state vector object with x_out and P_out
            x_out, P_out = self._update_state(x_out, P_out, sat_list)

            # save internal variables
            self._x = x_out
            self._P = P_out
            self._state.epoch = epoch
            self._prev_sat_list = sat_list

            # build the postfit residuals vector
            post_fit = self.get_postfit_residuals(epoch, pr_cp_obs_for_epoch, rr_obs_for_epoch, datatypes,
                                                  reconstructor, sat_list)
            norm = np.linalg.norm(post_fit)
            R_inv = np.diag(1.0 / np.diag(R))
            dop_matrix = np.linalg.inv(H.T @ R_inv @ H)

            # build prefit and postfit residual dicts for output
            pre_fit_dict = self.get_residuals(residuals_vector, sat_list, datatypes)
            post_fit_dict = self.get_residuals(post_fit, sat_list, datatypes)
            return pre_fit_dict, post_fit_dict, dop_matrix, norm

        except Exception as e:
            raise SolverError(str(e))

    @staticmethod
    def get_residuals(residual_vec, sat_list, datatypes):
        """
        Rearrange the residual vector (from a numpy.ndarray vector) into a more readable format.

        The output is a dictionary keyed by constellation, satellite, and datatype, such that:
            res_dict[constellation][sat][datatype] = residual

        Args:
            residual_vec (numpy.ndarray): The input residual vector to be rearranged.
            sat_list (list): List with available satellites for this epoch
            datatypes(dict): dict with constellations as keys and available datatypes as values

        Returns:
            dict: A dictionary with the rearranged residuals.
        """

        res_dict = dict()
        for const in datatypes.keys():
            n_sats = 0
            for sat in sat_list:
                if sat.sat_system == const:
                    n_sats += 1

            res_dict[const] = dict()
            iSat = 0
            for sat in sat_list:
                if sat.sat_system == const:
                    res_dict[const][sat] = dict()

                    for iFreq, datatype in enumerate(datatypes[const]):
                        res_dict[const][sat][datatype] = residual_vec[iFreq * n_sats + iSat]
                    iSat += 1
        return res_dict

    def get_postfit_residuals(self, epoch, pr_cp_obs_data, rr_obs_data,
                              datatypes, reconstructor_dict, sat_list):
        """
        Compute the postfit residuals after the estimated state has been updated for this epoch

        Args:
            epoch (src.data_types.date.Epoch): current epoch of estimation
            sat_list (list): List with available satellites for this epoch
            datatypes(dict): dict with constellations as keys and available datatypes as values
            reconstructor_dict(dict): internal dict with the objects for the observation re-constructors
            pr_cp_obs_data (src.data_mng.gnss.observation_data.EpochData) : instance of `EpochData` (GNSS observable
                database for the current epoch containing PR and CP measurements).
            rr_obs_data (src.data_mng.gnss.observation_data.EpochData) : instance of `EpochData` (GNSS observable
                database for the current epoch containing Doppler measurements).
        Returns:
            dict: the postfit residuals dict is returned.
        """
        obs_offset = 0
        n_obs_pr_cp = pr_cp_obs_data.get_number_of_pr_cp_observations(datatypes)
        n_obs_rr = rr_obs_data.get_number_of_doppler_observations(datatypes)
        n_obs = n_obs_pr_cp + n_obs_rr

        postfit_residuals = np.zeros(n_obs)

        for const in datatypes.keys():
            for datatype in datatypes[const]:

                if DataType.is_code(datatype):
                    reconstructor = reconstructor_dict["PR"]
                elif DataType.is_carrier(datatype):
                    reconstructor = reconstructor_dict["CP"]
                elif DataType.is_doppler(datatype):
                    reconstructor = reconstructor_dict["RR"]
                else:
                    raise SolverError(f"Unknown datatype {datatype} at epoch {epoch}.")

                iSat = 0
                for sat in sat_list:
                    if sat.sat_system != const:
                        continue

                    if DataType.is_code(datatype) or DataType.is_carrier(datatype):
                        r, _ = self.compute_residual_los(sat, epoch, datatype, pr_cp_obs_data, reconstructor)
                    else:
                        r, _ = self.compute_residual_los_rr(sat, epoch, datatype, rr_obs_data, reconstructor)

                    # filling the LS matrices
                    postfit_residuals[obs_offset + iSat] = r
                    iSat += 1
                obs_offset += iSat
        return postfit_residuals

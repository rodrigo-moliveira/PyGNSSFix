""" Module with Least-Squares engines for position and velocity estimators """
import numpy as np

from src import constants
from src.constants import SPEED_OF_LIGHT
from src.errors import SolverError
from src.io.config.enums import EnumModel
from src.modules.estimators.weighted_ls import WeightedLeastSquares


class LSQ_Engine:
    """
    Base class for the LSQ Engine.

    Two child classes are derived:
        * :py:class:`LSQ_Engine_Position` for the estimation of position and clock bias (with pseudorange measurements)
        * :py:class:`LSQ_Engine_Velocity` for the estimation of velocity and clock drift (with range rate measurements)

    Consider the linear system y = G @ x, where
        * y - observation vector
        * x - state vector
        * G - state matrix (relates state vector with the observation vector)

    Given the vector of observations y, the estimated state x^{hat} is given by (Normal Equation):
        x^{hat} = (G.T @ W @ G)^-1 @ G.T @ W @ y
    where W is the weight matrix.

    The `LSQ_Engine` class is responsible for filling the LSQ observation vector y and state matrices G and W.
    Then it calls an :py:class:`src.modules.estimators.WeightedLeastSquares` instance to solve the system and update
    the GNSS state vector object (:py:class:`src.data_mng.gnss.state_space.GnssStateSpace`) accordingly. This process
    is performed iteratively (Iterated Weighted Least-Squares).
    
            
    Attributes:
        datatypes(dict): dict with all the datatypes to be used
        y_vec(numpy.ndarray): observation vector
        design_mat(numpy.ndarray): state matrix
        weight_mat(numpy.ndarray): weight matrix
        constellations(list): list of the GNSS constellations to be used
        sat_list(dict): dict with available constellations as keys and available satellites to be used as values
    """

    def __init__(self, datatypes, satellite_list, metadata, epoch, obs_data, reconstructor):
        """
        Constructor of the LSQ_Engine instance.

        Args:
            datatypes(dict): dict with all the datatypes to be used (constellation as keys, list of datatypes as values)
            satellite_list(list): list with satellites to be processed
            metadata(dict): dictionary with metadata information about the user configurations and models (generated by
                the :py:class:`src.modules.gnss.solver.gnss_solver.GnssSolver` instance)
            epoch(src.data_types.date.Epoch): epoch to be solved
            obs_data (src.data_mng.gnss.observation_data.EpochData) : instance of `EpochData` (GNSS observable database
                for a single epoch)
            reconstructor(src.modules.gnss.solver.ObservationReconstructor): instance of the observation reconstructor
                class
        """
        self.datatypes = datatypes

        self.y_vec = None       # observation vector
        self.design_mat = None  # design matrix
        self.weight_mat = None  # weight matrix

        self._metadata = metadata
        self.constellations = metadata["CONSTELLATIONS"]  # master constellation is the first in the list
        self.sat_list = dict()
        for sat in satellite_list:
            if sat.sat_system not in self.sat_list:
                self.sat_list[sat.sat_system] = list()
            self.sat_list[sat.sat_system].append(sat)

        self._initialize_matrices()
        self._build_lsq(epoch, obs_data, reconstructor)

    def _initialize_matrices(self):
        """
        Initializes the observation vector y (attribute `y_vec`), the state matrix G (attribute `design_mat`) 
        and the weight matrix W (attribute `weight_mat`) to numpy objects of the correct size and shape 
        (initialized to zeros), according to the user configurations

        The size of the arrays depend on the number of observations (satellites and frequencies) available, the number
        of states to be estimated, etc.
        """
        pass

    def _build_lsq(self, epoch, obs_data, reconstructor):
        """
        Fills the observation vector y (attribute `y_vec`), the state matrix G (attribute `design_mat`) and the weight
        matrix W (attribute `weight_mat`) with the appropriate data.

        Args:
            epoch(src.data_types.date.Epoch): epoch to be solved
            obs_data (src.data_mng.gnss.observation_data.EpochData) : instance of `EpochData` (GNSS observable database
                for a single epoch)
            reconstructor(src.modules.gnss.solver.ObservationReconstructor): instance of the observation reconstructor
                class
        """
        pass

    @staticmethod
    def compute_residual_los(sat, epoch, datatype, obs_data, reconstructor):
        """
        Computes the prefit residuals (observed minus computed observation) and the line of sight vector w.r.t. 
            ECEF frame.

        Args:
            sat(src.data_types.gnss.Satellite): satellite to compute the residual and LOS
            epoch(src.data_types.date.Epoch): epoch to make the computation
            datatype(src.data_types.gnss.DataType): datatype (frequency band) to compute the residual
            obs_data (src.data_mng.gnss.observation_data.EpochData) : instance of `EpochData` (GNSS observable database
                for a single epoch)
            reconstructor(src.modules.gnss.solver.ObservationReconstructor): instance of the observation reconstructor
                class

        Returns:
             tuple[float, numpy.ndarray] : Tuple with the computed residual (in the units of the datatype)
                                        and the line of sight for [x, y, z] axis of ECEF frame
        """
        pass

    def solve_ls(self, state):
        """
        Solves the LS problem for this iteration.

        Args:
            state(src.data_mng.gnss.state_space.GnssStateSpace): GNSS state vector object

        Returns:
            tuple[dict, dict, numpy.ndarray, float]:
                * first element is a dict with the prefit residuals (indexed by constellation, satellite and datatype)
                * second element is a dict with the postfit residuals (indexed by constellation, satellite and datatype)
                * third element is a numpy array object with the DOP matrix, DOP = (G.T * G)^-1
                * fourth element is the norm of the postfit residuals vector
        
        Raises:
            SolverError: an exception is raised if the LS problem fails to be solved
        """
        try:
            solver = WeightedLeastSquares(self.y_vec, self.design_mat, W=self.weight_mat)
            solver.solve()
            dop_matrix = np.linalg.inv(self.design_mat.T @ self.design_mat)

        except (AttributeError, np.linalg.LinAlgError) as e:
            # failed to solve the LS: solution not possible
            raise SolverError(e)

        # get estimated state x^hat and covariance
        x_hat = solver.get_solution()
        cov = solver.get_cov()

        # update the state vector object with x^hat
        self._update_state(state, x_hat, cov)

        # build the postfit residuals vector
        post_fit = self.y_vec - self.design_mat @ x_hat
        norm = np.linalg.norm(post_fit)

        # build prefit and postfit residual dicts for output
        pre_fit_dict = self.get_residuals(self.y_vec)
        post_fit_dict = self.get_residuals(post_fit)

        return pre_fit_dict, post_fit_dict, dop_matrix, norm

    def _update_state(self, state, dX, cov):
        """
        Applies computed corrections and updates the GNSS state vector accordingly.

        Args:
            state(src.data_mng.gnss.state_space.GnssStateSpace): GNSS state vector object
            dX(numpy.ndarray): solution array `x^hat` of the LSQ Solver
            cov(numpy.ndarray): covariance matrix `S = (G.T @ W @ G)^-1` of the LSQ Solver
        """
        pass

    def get_residuals(self, residual_vec):
        """
        Rearrange the residual vector (from a numpy.ndarray vector) into a more readable format.

        The output is a dictionary keyed by constellation, satellite, and datatype, such that:
            res_dict[constellation][sat][datatype] = residual

        Args:
            residual_vec (numpy.ndarray): The input residual vector to be rearranged.

        Returns:
            dict: A dictionary with the rearranged residuals.
        """

        res_dict = dict()
        for const in self.constellations:
            n_sats = len(self.sat_list[const])
            res_dict[const] = dict()

            for iSat, sat in enumerate(self.sat_list[const]):
                res_dict[const][sat] = dict()

                for iFreq, datatype in enumerate(self.datatypes[const]):
                    res_dict[const][sat][datatype] = residual_vec[iFreq * n_sats + iSat]
        return res_dict


class LSQ_Engine_Position(LSQ_Engine):
    """
    LSQ_Engine_Position class inherits from :py:class:`LSQ_Engine`.

    The `LSQ_Engine_Position` class performs estimation of position and clock for a GNSS system using pseudorange
    observations from GPS and GAL constellations. The system can handle single or dual frequencies per constellation.

    Since the pseudorange equation is non-linear with respect to the user position, it has to be linearized.
    The linearized observation equation adopted in the model is:

        ΔPR = -LOS * Δr + ΔT + c * Δdt_r + ΔI + c * ΔISB

    where:
        - ΔPR: is the prefit residual (true minus computed PR observation)
        - LOS: Line of sight vector w.r.t. ECEF frame
        - Δr: Change in receiver position
        - ΔT: Change in tropospheric wet delay (when tropo estimation is enabled). ΔT = Δzwd * map_wet
        - c: Speed of light
        - Δdt_r: Change in receiver clock bias
        - ΔI: Change in ionospheric delay (when iono estimation is enabled). ΔI = mu * dI
        - ΔISB: Change in Inter System Bias (only enabled for the slave constellations)

    The terms in the right-hand side of the equation above form the state vector of the LSQ system. To evidence them,
    the equation can be re-written in matrix form:

        ΔPR = [-LOS map_wet c mu c] * [Δr Δzwd Δdt_r dI ΔISB]^T

    where [Δr Δzwd Δdt_r dI ΔISB] is the state vector (x^hat) of the LSQ problem.
    Depending on the user configuration, some states may be enabled or disabled (Δr and Δdt_r are mandatory).

    After the Normal Equation is solved, the GNSS state vector is updated accordingly

        * r -> r + Δr
        * dt_r -> dt_r + Δdt_r
        * I -> I + mu * dI
        * T -> T + map_wet * Δzwd
        * ISB -> ISB + ΔISB

    These new quantities are then used in the next iteration of the LSQ, for the new computation of the predicted
    pseudorange observation (see :py:class:`src.modules.gnss.solver.obs_reconstructor.PseudorangeReconstructor`).
    """

    def __init__(self, satellite_list, metadata, epoch, obs_data, reconstructor):
        datatypes = metadata["CODES"]
        super().__init__(datatypes, satellite_list, metadata, epoch, obs_data, reconstructor)

    def _initialize_matrices(self):
        """
        Initializes the observation vector y (attribute `y_vec`), the state matrix G (attribute `design_mat`)
        and the weight matrix W (attribute `weight_mat`) to numpy objects of the correct size and shape
        (initialized to zeros), according to the user configurations

        The size of the arrays depend on the number of observations (satellites and frequencies) available, the number
        of states to be estimated, etc.

        Different cases:
            Single Frequency Single Constellation
                -> States are position and clock
                -> Design matrix has shape [m_S,4]
                -> Observation vector has shape [m_S,1]
            Dual Frequency Single Constellation
                -> States are position, clock and iono
                -> Design matrix has shape [2*m_S,4+m_S]
                -> Observation vector has shape [2*m_S,1]
            Single Frequency Dual Constellation
                -> States are position, clock and isb
                -> Design matrix has shape [m_S1+m_S2,4+1]
                -> Observation vector has shape [m_S1+m_S2,1]
            Dual Frequency Dual Constellation
                -> States are position, clock, iono and isb
                -> Design matrix has shape [2*(m_S1+m_S2), 4+m_S1+m_S2+1]
                -> Observation vector has shape [2*(m_S1+m_S2),1]
            Dual constellation (constellation 1 with dual frequency and constellation 2 with single frequency)
                -> States: position, clock, iono and isb
                -> Design matrix is Design matrix has shape [2*m_S1+m_S2, 4+m_S1+1]
                -> Observation vector has shape [2*m_S1+m_S2,1]

        m_Si is the number of available satellites for the constellation i

        When tropo estimation is enabled, a new state is added to all cases above
        """
        n_observables = 0  # number of rows
        n_states = 3  # number of columns (default is 3 - position)

        for const in self.constellations:
            n_states += 1  # clock/isb variable

            n_sats = len(self.sat_list[const])

            # add iono states
            if self._metadata["MODEL"][const] == EnumModel.DUAL_FREQ:
                n_states += n_sats
                n_observables += 2 * n_sats
            else:
                n_observables += n_sats

        if self._metadata["TROPO"].estimate_tropo():
            n_states += 1

        self.y_vec = np.zeros(n_observables)
        self.design_mat = np.zeros((n_observables, n_states))
        self.weight_mat = np.eye(n_observables)

    @staticmethod
    def compute_residual_los(sat, epoch, datatype, obs_data, reconstructor):
        # get observable and compute predicted observable
        obs = float(obs_data.get_observable(sat, datatype))
        predicted_obs = reconstructor.compute(sat, epoch, datatype)

        # prefit residuals (observed minus computed)
        prefit_residuals = obs - predicted_obs

        # get LOS vector w.r.t. ECEF frame (column in geometry matrix)
        line_sight = reconstructor.get_unit_line_of_sight(sat)

        return prefit_residuals, line_sight

    def _build_lsq(self, epoch, obs_data, reconstructor):
        iono_offset = 0
        obs_offset = 0
        estimate_tropo = self._metadata["TROPO"].estimate_tropo()
        tropo_offset = 1 if estimate_tropo else 0

        for iConst, const in enumerate(self.constellations):

            n_sats = len(self.sat_list[const])
            for iFreq, datatype in enumerate(self.datatypes[const]):

                for iSat, sat in enumerate(self.sat_list[const]):
                    residual, los = self.compute_residual_los(sat, epoch, datatype, obs_data, reconstructor)

                    # filling the LS matrices
                    self.y_vec[obs_offset + iSat] = residual
                    self.design_mat[obs_offset + iSat][0:3] = los  # position
                    self.design_mat[obs_offset + iSat, 3] = 1.0  # clock
                    if estimate_tropo:
                        map_wet = reconstructor._system_geometry.get("tropo_map_wet", sat)
                        self.design_mat[obs_offset + iSat, 4] = map_wet
                    if self._metadata["MODEL"][const] == EnumModel.DUAL_FREQ:
                        factor = (self.datatypes[const][0].freq.freq_value / datatype.freq.freq_value) ** 2
                        self.design_mat[obs_offset + iSat, 4 + tropo_offset + iono_offset + iSat] = 1.0 * factor  # iono
                    if iConst > 0:
                        self.design_mat[obs_offset + iSat, -1] = 1.0  # ISB

                    # Weight matrix -> as 1/(obs_std^2)
                    std = reconstructor.get_obs_std(sat, datatype)
                    obs_data.get_observable(sat, datatype).set_std(std)
                    self.weight_mat[obs_offset + iSat, obs_offset + iSat] = \
                        1 / (std ** 2)

                obs_offset += n_sats
            if self._metadata["MODEL"][const] == EnumModel.DUAL_FREQ:
                iono_offset += n_sats

    def _update_state(self, state, dX, cov):
        estimate_tropo = self._metadata["TROPO"].estimate_tropo()
        tropo_offset = 1 if estimate_tropo else 0

        state.position += dX[0:3]
        state.clock_bias += dX[3] / constants.SPEED_OF_LIGHT  # receiver clock in seconds

        # if iono is estimated
        iono_offset = 0
        for const in self.constellations:
            if self._metadata["MODEL"][const] == EnumModel.DUAL_FREQ:
                for iSat, sat in enumerate(self.sat_list[const]):
                    state.iono[sat] += float(dX[iono_offset + iSat + 4 + tropo_offset])
                    state.cov_iono[sat] = cov[
                        iono_offset + iSat + 4 + tropo_offset, iono_offset + iSat + 4 + tropo_offset]
                iono_offset += len(self.sat_list[const])

        # ISB
        if len(self.constellations) > 1:
            state.isb += dX[-1] / constants.SPEED_OF_LIGHT  # ISB between master and slave constellations
            state.cov_isb = float(cov[-1, -1]) / (constants.SPEED_OF_LIGHT ** 2)  # in seconds^2

        # tropo
        if estimate_tropo:
            state.tropo_wet += dX[4]
            state.cov_tropo_wet = cov[4, 4]

        # unpack covariance matrices
        state.cov_position = np.array(cov[0:3, 0:3])
        state.cov_clock_bias = float(cov[3, 3]) / (constants.SPEED_OF_LIGHT ** 2)  # in seconds^2


class LSQ_Engine_Velocity(LSQ_Engine):
    """
    LSQ_Engine_Velocity class inherits from :py:class`LSQ_Engine`.

    The `LSQ_Engine_Velocity` class performs estimation of velocity and clock drift for a GNSS system using doppler
    observations from GPS and GAL constellations. Currently, the system can only handle single frequency data
    per constellation.

    Since the pseudorange rate equation is linear with respect to the user position, therefore no linearization is
    required and this process resorts to a standard WLS without the need to perform iterations.

    The range rate model is:
        PR_Rate = (v^sat - v_rec).LOS + c(clock_rate_rec - clock_rate_sat - rel_clock_rate_sat)

    where:
        - v^sat: inertial satellite velocity vector written in ECEF frame components
        - v_rec: inertial receiver velocity vector written in ECEF frame components
        - LOS: Line of sight vector w.r.t. ECEF frame
        - clock_rate_rec: receiver clock drift
        - clock_rate_sat: satellite clock drift
        - rel_clock_rate_sat: satellite relativistic clock drift correction

    Rearranging the terms in the equation above, we evidence in the right-hand side only the terms to be estimated
        PR_Rate - v^sat.LOS + c * (clock_rate_sat + rel_clock_rate_sat) = -v_rec.LOS + c(clock_rate_rec)

    The state vector (x^hat) of the LSQ Normal Equation is thus [v_rec, clock_rate_rec].

    NOTE: the LSQ System estimates the receiver inertial velocity, so it is required to remove the Earth rotation
    in order to get the ECEF velocity, cf. Eq. (21.29) of [1].
        v_rec(ECEF) = v_rec(ECI) - OMEGA_EARTH x r_rec

    See :py:class:`src.modules.gnss.solver.obs_reconstructor.RangeRateReconstructor` for the reconstruction of the
    pseudorange rate observation.

    Reference
        [1] Springer Handbook of Global Navigation Satellite Systems, Peter J.G. Teunissen, Oliver Montenbruck,
            Springer Cham, 2017
    """

    def __init__(self, satellite_list, metadata, epoch, obs_data, reconstructor):
        datatypes = metadata["DOPPLER"]
        # currently we always use one observation per constellation (dual-frequency is not possible)
        for key in datatypes:
            datatypes[key] = datatypes[key][:1]
        super().__init__(datatypes, satellite_list, metadata, epoch, obs_data, reconstructor)

    def _initialize_matrices(self):
        """
        Initializes the observation vector y (attribute `y_vec`), the state matrix G (attribute `design_mat`)
        and the weight matrix W (attribute `weight_mat`) to numpy objects of the correct size and shape
        (initialized to zeros), according to the user configurations

        The size of the arrays depend on the number of observations (satellites and frequencies) available, the number
        of states to be estimated, etc.

        Different cases:
            Single Frequency Single Constellation
                -> States are velocity and clock drift
                -> Design matrix has shape [m_S,3+1]
                -> Observation vector has shape [m_S,1]
            Single Frequency Dual Constellation
                -> States are velocity and clock drift per constellation
                -> Design matrix has shape [m_S1+m_S2,3+1+1]
                -> Observation vector has shape [m_S1+m_S2,1]
        """
        n_observables = 0  # number of rows
        n_states = 3  # number of columns (default is 3 - velocity)

        for const in self.constellations:
            n_sats = len(self.sat_list[const])
            n_observables += n_sats
            n_states += 1  # receiver clock rate for each constellation

        self.y_vec = np.zeros(n_observables)
        self.design_mat = np.zeros((n_observables, n_states))
        self.weight_mat = np.eye(n_observables)

    @staticmethod
    def compute_residual_los(sat, epoch, doppler_datatype, obs_data, reconstructor):

        # get observable and compute predicted observable
        obs = float(obs_data.get_observable(sat, doppler_datatype))  # in Hz

        # transform Doppler to pseudorange rate
        wavelength = SPEED_OF_LIGHT / doppler_datatype.freq_value  # in meters
        obs_range_rate = -wavelength * obs  # in m/s

        predicted_obs = reconstructor.compute(sat, epoch, doppler_datatype)

        # prefit residuals (observed minus computed)
        prefit_residuals = obs_range_rate - predicted_obs

        los = -reconstructor.get_unit_line_of_sight(sat)

        return prefit_residuals, los

    def _build_lsq(self, epoch, obs_data, reconstructor):
        obs_offset = 0
        const_offset = 0
        for iConst, const in enumerate(self.constellations):

            n_sats = len(self.sat_list[const])
            datatype = self.datatypes[const][0]

            for iSat, sat in enumerate(self.sat_list[const]):
                residual, los = self.compute_residual_los(sat, epoch, datatype, obs_data, reconstructor)

                # filling the LS matrices
                self.y_vec[obs_offset + iSat] = residual
                self.design_mat[obs_offset + iSat][0:3] = -los  # velocity
                self.design_mat[obs_offset + iSat][3 + const_offset] = 1

                # Weight matrix -> as 1/(obs_std^2)
                std = reconstructor.get_obs_std(sat, datatype)
                obs_data.get_observable(sat, datatype).set_std(std)
                self.weight_mat[obs_offset + iSat, obs_offset + iSat] = \
                    1 / (std ** 2)

            obs_offset += n_sats
            const_offset += 1

    def _update_state(self, state, dX, cov):
        vel = np.array(dX[0:3]) - np.cross(constants.EARTH_ANGULAR_RATE, state.position)
        state.velocity = vel  # in m/s
        state.cov_velocity = cov[0:3, 0:3]  # in (m/s)^2

        for iConst, const in enumerate(self.constellations):
            # receiver clock drift [dimensionless]
            state.clock_bias_rate[const] = dX[iConst + 3] / constants.SPEED_OF_LIGHT
            state.cov_clock_bias_rate[const] = float(cov[iConst + 3, iConst + 3]) / (constants.SPEED_OF_LIGHT ** 2)

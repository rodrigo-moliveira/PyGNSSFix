"""Module with Least-Squares engines for position and velocity estimators"""
import numpy as np

from src import constants
from src.constants import SPEED_OF_LIGHT
from src.errors import SolverError
from src.io.config.enums import EnumModel
from src.modules.estimators.weighted_ls import WeightedLeastSquares


class LSQ_Engine:
    def __init__(self, satellite_list, metadata, epoch, obs_data, reconstructor):
        """
        Base class for the LSQ Engine
        Two child classes are derived:
            * `LSQ_Engine_Position` for the estimation of position and clock bias (with pseudorange measurements)
            * `LSQ_Engine_Velocity` for the estimation of velocity and clock drift (with range rate measurements)

        Consider the linear system y = G @ x, where
            * y - observation vector
            * x - state vector
            * G - state matrix (relates state vector with the observation vector)

        Given the vector of observations y, the estimated state x^{hat} is given by:
            x^{hat} = (G.T @ W @ G)^-1 @ G.T @ W @ y
        where W is the weight matrix.

        The `LSQ_Engine` class is responsible for filling the LSQ observation vector y and state matrices G and W.
        Then it calls the :py:class:`src.modules.estimators.WeightedLeastSquares` object to solve the system and update
        the GNSS state vector object (:py:class:`src.data_mng.gnss.state_space.GnssStateSpace`) accordingly

        Parameters:
            satellite_list(list): list with satellites to be processed
            metadata(dict): dictionary with metadata information about the user configurations and models (generated by
                the :py:class:`src.modules.gnss.solver.gnss_solver.GnssSolver` instance)
            epoch(src.data_types.date.Epoch): epoch to be solved
            obs_data (src.data_mng.gnss.observation_data.EpochData) : instance of `EpochData` (GNSS observable database
                for a single epoch)
            reconstructor(src.modules.gnss.solver.ObservationReconstructor): instance of the observation reconstructor
                class
        """
        self.y_vec = None       # observation vector
        self.design_mat = None  # design matrix
        self.weight_mat = None  # weight matrix

        self._metadata = metadata
        self.constellations = metadata["CONSTELLATIONS"]  # master constellation is the first in the list
        self.sat_list = dict()
        for sat in satellite_list:
            if sat.sat_system not in self.sat_list:
                self.sat_list[sat.sat_system] = list()
            self.sat_list[sat.sat_system].append(sat)

        self._initialize_matrices()
        self._build_lsq(epoch, obs_data, reconstructor)

    def _initialize_matrices(self):
        """
        Initializes the observation vector y (`self.y_vec`), the state matrix G (`self.design_mat`) and the weight
        matrix W (`self.weight_mat`) to numpy objects of the correct size and shape (initialized to zeros),
        according to the user configurations

        The size of the arrays depend on the number of observations (satellites and frequencies) available, the number
        of states to be estimated, etc.
        """
        pass

    def _build_lsq(self, epoch, obs_data, reconstructor):
        """
        Fills the observation vector y (`self.y_vec`), the state matrix G (`self.design_mat`) and the weight
        matrix W (`self.weight_mat`) with the appropriate data.

        Parameters:
            epoch(src.data_types.date.Epoch): epoch to be solved
            obs_data (src.data_mng.gnss.observation_data.EpochData) : instance of `EpochData` (GNSS observable database
                for a single epoch)
            reconstructor(src.modules.gnss.solver.ObservationReconstructor): instance of the observation reconstructor
                class
        """
        pass

    @staticmethod
    def compute_residual_los(sat, epoch, datatype, obs_data, reconstructor):
        """
        Computes the prefit residuals (observed minus computed observation) and the
        line of sight vector w.r.t. ECEF frame

        Parameters:
            sat(src.data_types.gnss.Satellite): satellite to compute the residual and LOS
            epoch(src.data_types.date.Epoch): epoch to make the computation
            datatype(src.data_types.gnss.DataType): datatype (frequency band) to compute the residual
            obs_data (src.data_mng.gnss.observation_data.EpochData) : instance of `EpochData` (GNSS observable database
                for a single epoch)
            reconstructor(src.modules.gnss.solver.ObservationReconstructor): instance of the observation reconstructor
                class

        Returns:
             tuple[float, numpy.ndarray] : Tuple with the computed residual (in the units of the datatype)
                                        and the line of sight for [x, y, z] axis of ECEF frame
        """
        pass

    def solve_ls(self, state):
        """
        Solves the LS problem for this iteration

        Parameters:
            state(src.data_mng.gnss.state_space.GnssStateSpace): GNSS state vector object

        Returns:
            TODO: fill here...
        """
        try:
            solver = WeightedLeastSquares(self.y_vec, self.design_mat, W=self.weight_mat)
            solver.solve()
            dop_matrix = np.linalg.inv(self.design_mat.T @ self.design_mat)

        except (AttributeError, np.linalg.LinAlgError) as e:
            # failed to solve the LS: solution not possible
            raise SolverError(e)

        # update state vector with incremental dX
        dX = solver.get_solution()
        cov = solver.get_cov()

        # apply dX corrections to the state vector
        self._update_state(state, dX, cov)

        # form the post-fit residuals
        post_fit = self.y_vec - self.design_mat[:, 0:3] @ dX[0:3]
        norm = np.linalg.norm(post_fit)

        # form residual dicts for output
        pre_fit_dict = self.get_residuals(self.y_vec)
        post_fit_dict = self.get_residuals(post_fit)

        return pre_fit_dict, post_fit_dict, dop_matrix, norm

    def _update_state(self, state, dX, cov):
        """
        Applies computed corrections and updates the GNSS state vector accordingly

        Parameters:
            state(src.data_mng.gnss.state_space.GnssStateSpace): GNSS state vector object
            dX(numpy.ndarray): solution array `x^hat` of the LSQ Solver
            cov(numpy.ndarray): covariance matrix `S = (G.T @ W @ G)^-1` os the LSQ Solver
        """
        pass

    def get_residuals(self, residual_vec):
        pass


class LSQ_Engine_Position(LSQ_Engine):
    def __init__(self, satellite_list, metadata, epoch, obs_data, reconstructor):
        super().__init__(satellite_list, metadata, epoch, obs_data, reconstructor)

    def _initialize_matrices(self):
        """
        Different cases:
            Single Frequency Single Constellation
                -> States are position and clock
                -> Design matrix has shape [m_S,4]
                -> Observation vector has shape [m_S,1]
            Dual Frequency Single Constellation
                -> States are position, clock and iono
                -> Design matrix has shape [2*m_S,4+m_S]
                -> Observation vector has shape [2*m_S,1]
            Single Frequency Dual Constellation
                -> States are position, clock and isb
                -> Design matrix has shape [m_S1+m_S2,4+1]
                -> Observation vector has shape [m_S1+m_S2,1]
            Dual Frequency Dual Constellation
                -> States are position, clock, iono and isb
                -> Design matrix has shape [2*(m_S1+m_S2), 4+m_S1+m_S2+1]
                -> Observation vector has shape [2*(m_S1+m_S2),1]
            Dual constellation (constellation 1 with dual frequency and constellation 2 with single frequency)
                -> States: position, clock, iono and isb
                -> Design matrix is Design matrix has shape [2*m_S1+m_S2, 4+m_S1+1]
                -> Observation vector has shape [2*m_S1+m_S2,1]

        m_Si is the number of available satellites for the constellation i

        When tropo is added, a new state is added to all cases above
        """
        n_observables = 0  # number of rows
        n_states = 3  # number of columns (default is 3 - position)

        for const in self.constellations:
            n_states += 1  # clock/isb variable

            n_sats = len(self.sat_list[const])

            # add iono states
            if self._metadata["MODEL"][const] == EnumModel.DUAL_FREQ:
                n_states += n_sats
                n_observables += 2 * n_sats
            else:
                n_observables += n_sats

        if self._metadata["TROPO"].estimate_tropo():
            n_states += 1

        self.y_vec = np.zeros(n_observables)
        self.design_mat = np.zeros((n_observables, n_states))
        self.weight_mat = np.eye(n_observables)

    @staticmethod
    def compute_residual_los(sat, epoch, datatype, obs_data, reconstructor):
        # get observable and compute predicted observable
        obs = float(obs_data.get_observable(sat, datatype))
        predicted_obs = reconstructor.compute(sat, epoch, datatype)

        # prefit residuals (observed minus computed)
        prefit_residuals = obs - predicted_obs

        # get LOS vector w.r.t. ECEF frame (column in geometry matrix)
        line_sight = reconstructor.get_unit_line_of_sight(sat)

        return prefit_residuals, line_sight

    def _build_lsq(self, epoch, obs_data, reconstructor):
        iono_offset = 0
        obs_offset = 0
        estimate_tropo = self._metadata["TROPO"].estimate_tropo()
        tropo_offset = 1 if estimate_tropo else 0

        for iConst, const in enumerate(self.constellations):

            n_sats = len(self.sat_list[const])
            for iFreq, datatype in enumerate(self._metadata["CODES"][const]):

                for iSat, sat in enumerate(self.sat_list[const]):
                    residual, los = self.compute_residual_los(sat, epoch, datatype, obs_data, reconstructor)

                    # filling the LS matrices
                    self.y_vec[obs_offset + iSat] = residual
                    self.design_mat[obs_offset + iSat][0:3] = los  # position
                    self.design_mat[obs_offset + iSat, 3] = 1.0  # clock
                    if estimate_tropo:
                        map_wet = reconstructor._system_geometry.get("tropo_map_wet", sat)
                        self.design_mat[obs_offset + iSat, 4] = map_wet
                    if self._metadata["MODEL"][const] == EnumModel.DUAL_FREQ:
                        factor = (self._metadata["CODES"][const][0].freq.freq_value / datatype.freq.freq_value) ** 2
                        self.design_mat[obs_offset + iSat, 4 + tropo_offset + iono_offset + iSat] = 1.0 * factor  # iono
                    if iConst > 0:
                        self.design_mat[obs_offset + iSat, -1] = 1.0  # ISB

                    # Weight matrix -> as 1/(obs_std^2)
                    self.weight_mat[obs_offset + iSat, obs_offset + iSat] = \
                        1 / (reconstructor.get_obs_std(sat, datatype) ** 2)

                obs_offset += n_sats
            if self._metadata["MODEL"][const] == EnumModel.DUAL_FREQ:
                iono_offset += n_sats

    def _update_state(self, state, dX, cov):
        estimate_tropo = self._metadata["TROPO"].estimate_tropo()
        tropo_offset = 1 if estimate_tropo else 0

        state.position += dX[0:3]
        state.clock_bias += dX[3] / constants.SPEED_OF_LIGHT  # receiver clock in seconds

        # if iono is estimated
        iono_offset = 0
        for const in self.constellations:
            if self._metadata["MODEL"][const] == EnumModel.DUAL_FREQ:
                for iSat, sat in enumerate(self.sat_list[const]):
                    state.iono[sat] += float(dX[iono_offset + iSat + 4 + tropo_offset])
                    state.cov_iono[sat] = cov[
                        iono_offset + iSat + 4 + tropo_offset, iono_offset + iSat + 4 + tropo_offset]
                iono_offset += len(self.sat_list[const])

        # ISB
        if len(self.constellations) > 1:
            state.isb += dX[-1] / constants.SPEED_OF_LIGHT  # ISB between master and slave constellations
            state.cov_isb = float(cov[-1, -1]) / (constants.SPEED_OF_LIGHT ** 2)  # in seconds^2

        # tropo
        if estimate_tropo:
            state.tropo_wet += dX[4]
            state.cov_tropo_wet = cov[4, 4]

        # unpack covariance matrices
        state.cov_position = np.array(cov[0:3, 0:3])
        state.cov_clock_bias = float(cov[3, 3]) / (constants.SPEED_OF_LIGHT ** 2)  # in seconds^2

    def get_residuals(self, residual_vec):

        res_dict = dict()
        for const in self.constellations:
            n_sats = len(self.sat_list[const])
            res_dict[const] = dict()

            for iSat, sat in enumerate(self.sat_list[const]):
                res_dict[const][sat] = dict()

                for iFreq, datatype in enumerate(self._metadata["CODES"][const]):
                    res_dict[const][sat][datatype] = residual_vec[iFreq * n_sats + iSat]
        return res_dict


# Update the docstring of B.method to include the docstring of A.method
# LSQ_Engine_Position._initialize_matrices.__doc__ = LSQ_Engine._initialize_matrices.__doc__ + \
#                                                   '\n' + LSQ_Engine_Position._initialize_matrices.__doc__


class LSQ_Engine_Velocity(LSQ_Engine):

    def __init__(self, satellite_list, metadata, epoch, obs_data, reconstructor):
        super().__init__(satellite_list, metadata, epoch, obs_data, reconstructor)

    def _initialize_matrices(self):
        # TODO: por agora apenas single constellation GPS+GAL
        # different cases:
        #   * Single Frequency Single Constellation: States: position, clock
        #       -> Design matrix is [m_S,4]
        #       -> Observation vector is [m_S,1]
        #   * Dual Frequency Single Constellation: States: position, clock, iono
        #       -> Design matrix is [2*m_S,4+m_S]
        #       -> Observation vector is [2*m_S,1]
        #   * Single Frequency Dual Constellation: States: position, clock, isb
        #       -> Design matrix is [m_S1+m_S2,4+1]
        #       -> Observation vector is [m_S1+m_S2,1]
        #   * Dual Frequency Dual Constellation: States: position, clock, iono, isb
        #       -> Design matrix is [2*(m_S1+m_S2), 4+m_S1+m_S2+1]
        #       -> Observation vector is [2*(m_S1+m_S2),1]
        #   * (Single + Dual) Frequency Dual Constellation:
        #       -> States: position, clock, iono, isb. Design matrix is Design matrix is [2*m_S1+m_S2, 4+m_S1+1]
        #       -> Observation vector is [2*m_S1+m_S2,1]
        #  When tropo is added, a new state is incremented, that is 4 -> 4 + 1 in the dimensions above

        n_observables = 0  # number of rows
        n_states = 3  # number of columns (default is 3 - velocity)

        for const in self.constellations:
            n_sats = len(self.sat_list[const])
            n_observables += n_sats
            n_states += 1  # receiver clock rate for each constellation

        self.y_vec = np.zeros(n_observables)
        self.design_mat = np.zeros((n_observables, n_states))
        self.weight_mat = np.eye(n_observables)

    @staticmethod
    def compute_residual_los(sat, epoch, doppler_datatype, obs_data, reconstructor):

        # get observable and compute predicted observable
        obs = float(obs_data.get_observable(sat, doppler_datatype))  # in Hz

        # transform Doppler to pseudorange rate
        wavelength = SPEED_OF_LIGHT / doppler_datatype.freq_value  # in meters
        obs_range_rate = -wavelength * obs  # in m/s

        predicted_obs = reconstructor.compute(sat, epoch, doppler_datatype)

        # prefit residuals (observed minus computed)
        prefit_residuals = obs_range_rate - predicted_obs

        los = -reconstructor.get_unit_line_of_sight(sat)

        return prefit_residuals, los

    def _build_lsq(self, epoch, obs_data, reconstructor):
        obs_offset = 0
        const_offset = 0
        for iConst, const in enumerate(self.constellations):

            n_sats = len(self.sat_list[const])
            datatype = self._metadata["DOPPLER"][const][0]

            for iSat, sat in enumerate(self.sat_list[const]):
                residual, los = self.compute_residual_los(sat, epoch, datatype, obs_data, reconstructor)

                # filling the LS matrices
                self.y_vec[obs_offset + iSat] = residual
                self.design_mat[obs_offset + iSat][0:3] = -los  # velocity
                self.design_mat[obs_offset + iSat][3 + const_offset] = 1

                # Weight matrix -> as 1/(obs_std^2)
                self.weight_mat[obs_offset + iSat, obs_offset + iSat] = \
                    1 / (reconstructor.get_obs_std(sat, datatype) ** 2)

            obs_offset += n_sats
            const_offset += 1

    def _update_state(self, state, dX, cov):
        """applies corrections to the state vector"""

        # NOTA!!! é necessário retirar a Earth velocity ao dX!!! cf. a Eq (21.29)
        vel = np.array(dX[0:3]) - np.cross(constants.EARTH_ANGULAR_RATE, state.position)
        state.velocity = vel  # in m/s
        state.cov_velocity = cov[0:3, 0:3]  # in (m/s)^2

        for iConst, const in enumerate(self.constellations):
            # receiver clock drift [dimensionless]
            state.clock_bias_rate[const] = dX[iConst + 3] / constants.SPEED_OF_LIGHT
            state.cov_clock_bias_rate[const] = float(cov[iConst + 3, iConst + 3]) / (constants.SPEED_OF_LIGHT ** 2)

    def get_residuals(self, residual_vec):

        res_dict = dict()
        iSat = 0
        for const in self.constellations:
            res_dict[const] = dict()

            for sat in self.sat_list[const]:
                res_dict[const][sat] = residual_vec[iSat]
                iSat += 1

        return res_dict

""" Module with Pseudorange and Range Rate Reconstructor classes"""
import numpy as np

from src.data_types.gnss.data_type import DataType
from src.io.config import config_dict
from src.io.config.enums import EnumOnOff, EnumModel
from src.models.frames import cartesian2geodetic
from src.models.gnss_models.navigation import nav_sat_clock_correction
from src.data_types.gnss.observation import Observation
from src import constants


class PseudorangeReconstructor:
    """
    Reconstructor of pseudorange observations, according to the following equation

        PR = rho + dt_rec - dt_sat + iono + tropo + dI
    where:
        * PR is the reconstructed pseudorange observation
        * rho is the true range (geometrical distance between satellite at TX time and receiver at RX time)
        * dt_rec is the receiver clock bias (with proper ISB applied, if necessary)
        * dt_sat is the satellite clock bias (corrected for broadcast group delay and relativistic corrections)
        * iono is the a-priori ionospheric delay
        * tropo is the tropospheric delay (a-priori model or estimated in the solver)
        * dI is the estimated ionospheric residual
    """
    def __init__(self, system_geometry, metadata, state):
        """
        Constructor of the `PseudorangeReconstructor` instances

        Parameters:
            system_geometry(src.data_mng.gnss.geometry.SystemGeometry): instance of `SystemGeometry` to be used in the
                reconstruction models
            metadata(dict): dictionary with metadata information about the user configurations and models (generated by
                the :py:class:`src.modules.gnss.solver.gnss_solver.GnssSolver` instance)
            state(src.data_mng.gnss.state_space.GnssStateSpace): current GNSS State
        """
        self._metadata = metadata
        self._state = state
        self._system_geometry = system_geometry

    def compute(self, sat, epoch, datatype):
        """
        Compute the pseudorange observation for the provided satellite, epoch and datatype

        Arguments:
            sat(src.data_types.gnss.Satellite): satellite to compute the pseudorange
            epoch(src.data_types.date.Epoch): epoch to compute the pseudorange
            datatype(src.data_types.gnss.DataType): datatype to compute the pseudorange

        Returns:
            Observation: Computed pseudorange Observation
        """
        iono = 0.0
        az = self._system_geometry.get("az", sat)  # satellite azimuth from receiver
        el = self._system_geometry.get("el", sat)  # satellite elevation from receiver
        [lat, long, height] = cartesian2geodetic(*self._state.position)  # user lat, long and height

        # true range
        true_range = self._system_geometry.get("true_range", sat)

        # user clock in meters (with proper ISB applied, if necessary)
        sat_clocks = self._system_geometry.sat_clocks
        time_correction = sat_clocks.nav_data.header.time_correction if sat_clocks.nav_data is not None else None
        dt_rec = self._state.get_clock_bias(sat.sat_system, time_correction) * constants.SPEED_OF_LIGHT

        # satellite clock
        dt_sat = sat_clocks.get_clock(sat, epoch)

        # correct satellite clock for relativistic corrections
        if self._metadata["REL_CORRECTION"] == EnumOnOff.ENABLED:
            dt_sat += self._system_geometry.get("dt_rel_correction", sat)

        # correct satellite clock for BGDs. NOTE: this needs to change (add a DCB manager)
        # DCB data can either come from a precise file or from the nav message
        nav_message = sat_clocks.get_nav_message(sat, epoch)
        dt_sat = nav_sat_clock_correction(dt_sat, datatype, nav_message)

        # ionosphere (a-priori correction)
        iono_corrections = sat_clocks.nav_data.header.iono_corrections if sat_clocks.nav_data is not None else None
        if not DataType.is_iono_free_code(datatype) and not DataType.is_iono_free_smooth_code(datatype):
            iono = self._metadata["IONO"][sat.sat_system].compute_iono_delay(
                epoch, iono_corrections, sat, lat, long, el, az, datatype.freq)

        # iono estimated correction dI
        dI = 0.0
        if self._metadata["MODEL"][sat.sat_system] == EnumModel.DUAL_FREQ:
            try:
                factor = (self._metadata["CODES"][sat.sat_system][0].freq.freq_value /
                          datatype.freq.freq_value) ** 2
                dI = factor * self._state.iono[sat]
            except KeyError:
                pass

        # troposphere
        tropo, map_wet = self._metadata["TROPO"].compute_tropo_delay(lat, long, height, el, epoch,
                                                                     self._state.tropo_wet)
        self._system_geometry.set("tropo_map_wet", map_wet, sat)

        # finally, construct obs
        obs = true_range + dt_rec - dt_sat * constants.SPEED_OF_LIGHT + iono + tropo + dI
        return Observation(datatype, obs)

    def get_unit_line_of_sight(self, sat):
        """
        Computes the line of sight vector between the receiver and the satellite, used in the PVT geometry matrix.

        Args:
            sat (src.data_types.gnss.Satellite) : satellite to compute the LOS vector

        Return:
            numpy.ndarray : Line of sight for [x, y, z] axis of ECEF frame
        """
        return self._system_geometry.get_unit_line_of_sight(sat)

    def get_obs_std(self, sat, datatype):
        """
        Returns standard deviation for the provided `datatype` according to the std defined in the user configurations.
        If the `elevation_mask` is activated, then the std is computed as
            std = exp(-elevation) * user_std

        Arguments:
            sat(src.data_types.gnss.Satellite) : satellite to compute the std
            datatype(src.data_types.gnss.data_type.DataType): pseudorange datatype to compute the std

        Returns:
            float: the computed standard deviation for the pseudorange datatype
        """
        elevation_mask = config_dict.get("model", sat.sat_system, "elevation_mask")
        el_std = 1.0
        if elevation_mask:
            elevation = self._system_geometry.get("el", sat)
            el_std = np.e ** (-elevation)
        try:
            obs_std = config_dict.get_obs_std()[sat.sat_system][datatype]
        except KeyError:
            from src.common_log import get_logger, MODEL_LOG
            get_logger(MODEL_LOG).warning(f"Unable to get user-defined std for satellite {sat} and datatype "
                                          f"{datatype}. User configurations are: {config_dict.get_obs_std()}")
            obs_std = 1.0
        return el_std * obs_std


class RangeRateReconstructor:
    def __init__(self, system_geometry, metadata, state):
        self._metadata = metadata
        self._state = state
        self._system_geometry = system_geometry

    def compute(self, sat, epoch, datatype):
        # reconstruct the pseudorange rate observation
        # pseudorange rate = (v^sat - v_rec).e_los + c(clock_rate_rec - clock_rate_sat - rel_clock_rate_sat)

        v_sat = self._system_geometry.get("satellite_velocity", sat)
        los = -1 * self.get_unit_line_of_sight(sat)
        v_rec_ = self._state.velocity + np.cross(constants.EARTH_ANGULAR_RATE, self._state.position)
        clock_rate_rec = self._state.clock_bias_rate

        # TODO: it could be possible to apply here the satellite clock drift correction

        return np.dot(v_sat - v_rec_, los) + constants.SPEED_OF_LIGHT * clock_rate_rec[sat.sat_system]

    def get_unit_line_of_sight(self, sat):
        los = self._system_geometry.get_unit_line_of_sight(sat)

        # correct line of sight, according to Eq. (21.28) of Handbook
        v_sat = self._system_geometry.get("satellite_velocity", sat)
        los = los / (1 + np.dot(v_sat, los) / constants.SPEED_OF_LIGHT)

        return los

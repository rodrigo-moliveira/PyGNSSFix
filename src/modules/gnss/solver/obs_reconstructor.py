""" Module with Pseudorange, Carrier Phase and Range Rate Observation Reconstructor Classes """
import numpy as np
import os

import src.data_mng.gnss.geometry
from src.data_types.gnss.data_type import DataType, get_data_type
from src.io.config import config_dict
from src.io.config.enums import EnumOnOff
from src.models.frames import cartesian2geodetic
from src.models.gnss_models import receiver_phase_center_correction, satellite_phase_center_correction
from src import constants


class ObservationReconstructor:
    """
    Base class for the Observation Reconstruction classes.
    """
    __trace_header__ = "None"

    def __init__(self, system_geometry: src.data_mng.gnss.geometry.SystemGeometry, metadata: dict,
                 state: src.data_mng.gnss.state_space.GnssStateSpace, trace_file):
        """
        Constructor of the `ObservationReconstructor` instances.

        Args:
            system_geometry(src.data_mng.gnss.geometry.SystemGeometry): instance of `SystemGeometry` to be used in the
                reconstruction models
            metadata(dict): dictionary with metadata information about the user configurations and models (generated by
                the :py:class:`src.modules.gnss.solver.gnss_solver.GnssSolver` instance)
            state(src.data_mng.gnss.state_space.GnssStateSpace): current GNSS State
            trace_file(str or None): path to the trace file
        """
        self._metadata = metadata
        self._state = state
        self._system_geometry = system_geometry
        self._trace_handler = None
        self._write_trace = False

        if trace_file is not None:
            self._write_trace = True

            if os.path.isfile(trace_file):
                self._trace_handler = open(trace_file, mode='a')
            else:
                self._trace_handler = open(trace_file, mode='w')
                self._trace_handler.write(f"{self.__trace_header__}\n")  # header

    def __del__(self):
        """ Destructor of the`ObservationReconstructor` instances. """
        if self._write_trace and self._trace_handler is not None:
            self._trace_handler.close()

    def compute(self, sat, epoch, datatype):
        """
        Compute the observation for the provided satellite, epoch and datatype.

        Args:
            sat(src.data_types.gnss.Satellite): satellite to compute the observation
            epoch(src.data_types.date.Epoch): epoch to compute the observation
            datatype(src.data_types.gnss.DataType): datatype (frequency band) to compute the observation

        Returns:
            float: Computed observable (numeric value)
        """
        return 0.0

    def get_unit_line_of_sight(self, sat):
        """
        Computes the line of sight vector between the receiver and the satellite, used in the PVT geometry matrix.

        Args:
            sat (src.data_types.gnss.Satellite) : satellite to compute the LOS vector

        Returns:
            numpy.ndarray : Line of sight for [x, y, z] axis of ECEF frame
        """
        return self._system_geometry.get_unit_line_of_sight(sat)

    def get_obs_std(self, sat, datatype):
        """
        Returns standard deviation for the provided satellite and `datatype` according to the std defined in
        the user configurations.
        Updates the std field in the associated Observation object.

        If the `elevation_mask` configuration is activated, then the returned std is computed as
            std = exp(-elevation) * user_std

        Otherwise, the returned std is simply the user-defined one
            std = user_std

        Args:
            sat(src.data_types.gnss.Satellite) : satellite to compute the std
            datatype(src.data_types.gnss.data_type.DataType): observation datatype to compute the std

        Returns:
            float: computed observation noise standard deviation for the provided datatype and satellite
        """
        elevation_mask = config_dict.get("model", sat.sat_system, "elevation_mask")
        el_std = 1.0
        if elevation_mask:
            elevation = self._system_geometry.get("el", sat)
            el_std = np.exp(-elevation)
        try:
            _dt = datatype
            if DataType.is_smooth_code(datatype):
                _dt = get_data_type(datatype.data_type[1:], datatype.constellation)
            obs_std = config_dict.get_obs_std()[sat.sat_system][_dt]
        except KeyError:
            from src.common_log import get_logger, MODEL_LOG
            get_logger(MODEL_LOG).warning(f"Unable to get user-defined std for satellite {sat} and datatype "
                                          f"{datatype}. User configurations are: {config_dict.get_obs_std()}")
            obs_std = 1.0
        return el_std * obs_std


class PseudorangeReconstructor(ObservationReconstructor):
    """
    Reconstructor of pseudorange observations, according to the following equation.

        PR = rho + dt_rec - dt_sat + iono + tropo + dI + pcc_rec + pcc_sat
    where:
        * PR is the reconstructed pseudorange observation
        * rho is the true range (geometrical distance between satellite at TX time and receiver at RX time)
        * dt_rec is the receiver clock bias (with proper ISB applied, if necessary)
        * dt_sat is the satellite clock bias (corrected for broadcast group delay and relativistic corrections)
        * iono is the a-priori ionospheric delay
        * tropo is the tropospheric delay (a-priori model or estimated in the solver)
        * dI is the estimated ionospheric residual
        * pcc_rec is the receiver antenna phase center correction (ARP, PCO, PCV)
        * pcc_sat is the satellite antenna phase center correction (PCO, PCV)
    """
    __trace_header__ = "epoch,sat,datatype,observation,true_range,receiver_clock,satellite_clock," \
                       "satellite_bias,iono_model,tropo,iono_correction,pcc_rec,pcc_sat"

    def __init__(self, system_geometry: src.data_mng.gnss.geometry.SystemGeometry, metadata: dict,
                 state: src.data_mng.gnss.state_space.GnssStateSpace, trace_data: tuple):
        """
        Constructor of the `PseudorangeReconstructor` instances.

        Args:
            system_geometry(src.data_mng.gnss.geometry.SystemGeometry): instance of `SystemGeometry` to be used in the
                reconstruction models
            metadata(dict): dictionary with metadata information about the user configurations and models (generated by
                the :py:class:`src.modules.gnss.solver.gnss_solver.GnssSolver` instance)
            state(src.data_mng.gnss.state_space.GnssStateSpace): current GNSS State
            trace_data(tuple or None): path to the trace dir and iteration number

        """
        if trace_data is not None:
            trace_file = f"{trace_data[0]}\\PseudorangeReconstructionIter_{trace_data[1]}.txt"
        else:
            trace_file = None
        super().__init__(system_geometry, metadata, state, trace_file)

    def compute(self, sat, epoch, datatype):
        """
        Compute the pseudorange observation for the provided satellite, epoch and datatype.

        Args:
            sat(src.data_types.gnss.satellite.Satellite): satellite instance
            epoch(src.data_types.date.Epoch): epoch instance
            datatype(src.data_types.gnss.data_type.DataType): DataType instance
        """
        iono = 0.0
        az = self._system_geometry.get("az", sat)  # satellite azimuth from receiver
        el = self._system_geometry.get("el", sat)  # satellite elevation from receiver
        [lat, long, height] = cartesian2geodetic(*self._state.position)  # user lat, long and height

        # true range
        true_range = self._system_geometry.get("true_range", sat)

        # user clock in meters (with proper ISB applied, if necessary)
        sat_clocks = self._system_geometry.sat_clocks
        time_correction = sat_clocks.nav_data.header.time_correction if sat_clocks.nav_data is not None else None
        dt_rec = self._state.get_clock_bias(sat.sat_system, time_correction)  # receiver clock bias in [m]

        # get satellite clock at time of transmission
        time_emission = self._system_geometry.get("time_emission", sat)
        dt_sat, _ = sat_clocks.get_clock(sat, time_emission)

        # correct satellite clock for relativistic corrections
        if self._metadata["REL_CORRECTION"] == EnumOnOff.ENABLED:
            dt_sat += self._system_geometry.get("dt_rel_correction", sat)

        # correct satellite clock for (code or phase) hardware biases
        # DCB data can either come from a precise file or from the nav message
        bias = self._system_geometry.sat_bias.bias_correction(epoch, sat, datatype)

        # ionosphere (a-priori correction)
        iono_corrections = sat_clocks.nav_data.header.iono_corrections if sat_clocks.nav_data is not None else None
        if not DataType.is_iono_free_code(datatype) and not DataType.is_iono_free_smooth_code(datatype):
            iono = self._metadata["IONO"][sat.sat_system].compute_iono_delay(
                epoch, iono_corrections, sat, lat, long, el, az, datatype.freq)

        # iono estimated correction dI
        dI = 0.0
        if self._metadata["IONO"][sat.sat_system].estimate_diono():
            try:
                factor = (self._metadata["CODES"][sat.sat_system][0].freq.freq_value /
                          datatype.freq.freq_value) ** 2
                dI = factor * self._state.iono[sat]
            except KeyError or TypeError:
                pass

        # troposphere
        tropo, map_wet = self._metadata["TROPO"].compute_tropo_delay(lat, long, height, el, epoch,
                                                                     self._state.tropo_wet)
        self._system_geometry.set("tropo_map_wet", map_wet, sat)

        # receiver antenna phase center corrections
        pcc_rec = pcc_sat = 0.0
        if self._system_geometry.phase_center.enabled:
            los = self.get_unit_line_of_sight(sat)
            try:
                rec_antenna = self._system_geometry.phase_center.get_receiver_antenna()
                pcc_rec = receiver_phase_center_correction(rec_antenna, datatype, los, lat, long, az, el)
            except Exception as e:
                from src.common_log import get_logger, MODEL_LOG
                get_logger(MODEL_LOG).warning(f"Error computing receiver antenna correction for "
                                              f"{epoch}, datatype {datatype} and sat {str(sat)}: {e}")
            try:
                dcm_b_e = self._system_geometry.get("dcm_b_e", sat)
                nadir_sat = self._system_geometry.get("nadir_sat", sat)
                azimuth_sat = self._system_geometry.get("azimuth_sat", sat)
                sat_antenna = self._system_geometry.phase_center.get_satellite_antenna(sat)
                pcc_sat = satellite_phase_center_correction(sat_antenna, dcm_b_e, datatype, los, nadir_sat, azimuth_sat)
            except Exception as e:
                from src.common_log import get_logger, MODEL_LOG
                get_logger(MODEL_LOG).warning(f"Error computing satellite antenna correction for "
                                              f"{epoch}, datatype {datatype} and sat {str(sat)}: {e}")

        # finally, construct obs
        obs = true_range + dt_rec - (dt_sat - bias) * constants.SPEED_OF_LIGHT + iono + tropo + dI + pcc_rec + pcc_sat
        if self._write_trace:
            self._trace_handler.write(f"{epoch},{sat},{datatype},{obs},{true_range},{dt_rec},"
                                      f"{dt_sat * constants.SPEED_OF_LIGHT},{bias * constants.SPEED_OF_LIGHT},"
                                      f"{iono},{tropo},{dI},{pcc_rec},{pcc_sat}\n")
        return obs


class CarrierPhaseReconstructor(ObservationReconstructor):
    """
    Reconstructor of carrier phase observations, according to the following equation.

        CP = rho + dt_rec + phase_bias - dt_sat - (iono + dI) + tropo + lambda * N + pcc_rec + pcc_sat
    where:
        * CP is the reconstructed carrier phase observation
        * rho is the true range (geometrical distance between satellite at TX time and receiver at RX time)
        * dt_rec is the receiver clock bias (with proper ISB applied, if necessary), with pseudorange hardware bias
        * dt_sat is the satellite clock bias (with pseudorange hardware bias)
        * iono is the a-priori ionospheric delay
        * tropo is the tropospheric delay (a-priori model or estimated in the solver)
        * dI is the estimated ionospheric residual
        * phase_bias is the receiver phase bias (hardware bias) for this frequency
        * N is the ambiguity (float or integer) in cycles
        * lambda is the wavelength of the signal in meters
        * pcc_rec is the receiver antenna phase center correction (ARP, PCO, PCV)
        * pcc_sat is the satellite antenna phase center correction (PCO, PCV)
    """
    __trace_header__ = "epoch,sat,datatype,observation,true_range,receiver_clock,satellite_clock," \
                       "receiver_phase_bias,satellite_bias,iono_model,ambiguity,tropo,iono_correction,pcc_rec,pcc_sat"

    def __init__(self, system_geometry: src.data_mng.gnss.geometry.SystemGeometry, metadata: dict,
                 state: src.data_mng.gnss.state_space.GnssStateSpace, trace_data: tuple):
        """
        Constructor of the `CarrierPhaseReconstructor` instances.

        Args:
            system_geometry(src.data_mng.gnss.geometry.SystemGeometry): instance of `SystemGeometry` to be used in the
                reconstruction models
            metadata(dict): dictionary with metadata information about the user configurations and models (generated by
                the :py:class:`src.modules.gnss.solver.gnss_solver.GnssSolver` instance)
            state(src.data_mng.gnss.state_space.GnssStateSpace): current GNSS State
            trace_data(tuple or None): path to the trace dir and iteration number

        """
        if trace_data is not None:
            trace_file = f"{trace_data[0]}\\CarrierPhaseReconstructionIter_{trace_data[1]}.txt"
        else:
            trace_file = None
        super().__init__(system_geometry, metadata, state, trace_file)

    def compute(self, sat, epoch, datatype):
        """
        Compute the carrier phase observation for the provided satellite, epoch and datatype.

        Args:
            sat(src.data_types.gnss.satellite.Satellite): satellite instance
            epoch(src.data_types.date.Epoch): epoch instance
            datatype(src.data_types.gnss.data_type.DataType): DataType instance
        """
        iono = 0.0
        az = self._system_geometry.get("az", sat)  # satellite azimuth from receiver
        el = self._system_geometry.get("el", sat)  # satellite elevation from receiver
        [lat, long, height] = cartesian2geodetic(*self._state.position)  # user lat, long and height

        # true range
        true_range = self._system_geometry.get("true_range", sat)

        # user clock in meters (with proper ISB applied, if necessary)
        sat_clocks = self._system_geometry.sat_clocks
        time_correction = sat_clocks.nav_data.header.time_correction if sat_clocks.nav_data is not None else None
        dt_rec = self._state.get_clock_bias(sat.sat_system, time_correction)  # receiver clock bias in [m]

        # receiver phase bias in [m]
        try:
            phase_bias = self._state.phase_bias[sat.sat_system][datatype]  # receiver phase bias in [m]
        except KeyError:
            phase_bias = 0
            from src.common_log import get_logger, MODEL_LOG
            get_logger(MODEL_LOG).warning(f"Error fetching phase bias for satellite {sat.sat_system} "
                                          f"and datatype {datatype}. Using 0.0 as default value.")

        # get satellite clock at time of transmission
        time_emission = self._system_geometry.get("time_emission", sat)
        dt_sat, _ = sat_clocks.get_clock(sat, time_emission)

        # correct satellite clock for relativistic corrections
        if self._metadata["REL_CORRECTION"] == EnumOnOff.ENABLED:
            dt_sat += self._system_geometry.get("dt_rel_correction", sat)

        # correct satellite clock for (code or phase) hardware biases
        # DCB data can either come from a precise file or from the nav message
        bias = self._system_geometry.sat_bias.bias_correction(epoch, sat, datatype)

        # ionosphere (a-priori correction)
        iono_corrections = sat_clocks.nav_data.header.iono_corrections if sat_clocks.nav_data is not None else None
        if not DataType.is_iono_free_carrier(datatype):
            iono = self._metadata["IONO"][sat.sat_system].compute_iono_delay(
                epoch, iono_corrections, sat, lat, long, el, az, datatype.freq)

        # iono estimated correction dI
        dI = 0.0
        if self._metadata["IONO"][sat.sat_system].estimate_diono():
            try:
                factor = (self._metadata["CODES"][sat.sat_system][0].freq.freq_value /
                          datatype.freq.freq_value) ** 2
                dI = factor * self._state.iono[sat]
            except KeyError or TypeError:
                pass

        # troposphere
        tropo, map_wet = self._metadata["TROPO"].compute_tropo_delay(lat, long, height, el, epoch,
                                                                     self._state.tropo_wet)
        self._system_geometry.set("tropo_map_wet", map_wet, sat)

        # receiver antenna phase center corrections
        pcc_rec = pcc_sat = 0.0
        if self._system_geometry.phase_center.enabled:
            los = self.get_unit_line_of_sight(sat)
            try:
                rec_antenna = self._system_geometry.phase_center.get_receiver_antenna()
                pcc_rec = receiver_phase_center_correction(rec_antenna, datatype, los, lat, long, az, el)
            except Exception as e:
                from src.common_log import get_logger, MODEL_LOG
                get_logger(MODEL_LOG).warning(f"Error computing receiver antenna correction for "
                                              f"{epoch}, datatype {datatype} and sat {str(sat)}: {e}")
            try:
                dcm_b_e = self._system_geometry.get("dcm_b_e", sat)
                nadir_sat = self._system_geometry.get("nadir_sat", sat)
                azimuth_sat = self._system_geometry.get("azimuth_sat", sat)
                sat_antenna = self._system_geometry.phase_center.get_satellite_antenna(sat)
                pcc_sat = satellite_phase_center_correction(sat_antenna, dcm_b_e, datatype, los, nadir_sat, azimuth_sat)
            except Exception as e:
                from src.common_log import get_logger, MODEL_LOG
                get_logger(MODEL_LOG).warning(f"Error computing satellite antenna correction for "
                                              f"{epoch}, datatype {datatype} and sat {str(sat)}: {e}")

        # ambiguity
        pivot_dict = self._state.get_additional_info("pivot")
        if sat is not pivot_dict[sat.sat_system]:
            N = self._state.ambiguity[sat][datatype].val
            wavelength = constants.SPEED_OF_LIGHT / datatype.freq.freq_value
        else:
            N = wavelength = 0.0

        # finally, construct obs
        obs = true_range + dt_rec + phase_bias - (dt_sat - bias) * constants.SPEED_OF_LIGHT - iono + tropo - \
              dI + pcc_rec + pcc_sat + wavelength * N
        if self._write_trace:
            self._trace_handler.write(f"{epoch},{sat},{datatype},{obs},{true_range},{dt_rec},"
                                      f"{dt_sat * constants.SPEED_OF_LIGHT},{phase_bias},"
                                      f"{bias * constants.SPEED_OF_LIGHT},"
                                      f"{iono},{wavelength * N},{tropo},{dI},{pcc_rec},{pcc_sat}\n")
        return obs


class RangeRateReconstructor(ObservationReconstructor):
    """
    Reconstructor of pseudorange rate observations.

    The adopted model for pseudorange rate observations is the following:

        PR_Rate = (v^sat - v_rec).los_cor + c(clock_rate_rec - clock_rate_sat - rel_clock_rate_sat)
    where:
        * v^sat(t-tau) = R(-tau) v^sat(t-tau) + w * dR/dt r^sat(t-tau) is the inertial satellite velocity rotated to
            the ECEF frame at the RX epoch. See method `compute_orbit_at_rx_time` of
            :py:class:`src.data_mng.gnss.sat_orbit_data.SatelliteOrbits`
        * v_rec(t) = dr/dt_rec(t) + w * r_rec(t) is the inertial receiver velocity in the ECEF frame defined at the
            RX epoch
        * los_cor = los / (1 + v^sat . los / c) is the line of sight corrected for the Earth rotation
        * clock_rate_rec is the receiver clock drift correction
        * clock_rate_sat is the satellite clock drift correction (without relativistic correction)
        * rel_clock_rate_sat is the satellite relativistic clock drift correction
        * tau is the transmission time and R is the rotation matrix from ECEF to ECI

    The units of PR_Rate are m/s

    Reference
        [1] Springer Handbook of Global Navigation Satellite Systems, Peter J.G. Teunissen, Oliver Montenbruck,
            Springer Cham, 2017

    The details for the range rate model above may be found in [1]. See Chapter 21.2.1 and Equations (21.28), (21.29)

    """
    __trace_header__ = "epoch,sat,datatype,observation,sat_range_rate,satellite_clock_drift"

    def __init__(self, system_geometry: src.data_mng.gnss.geometry.SystemGeometry, metadata: dict,
                 state: src.data_mng.gnss.state_space.GnssStateSpace, trace_data):
        """
        Constructor of the `RangeRateReconstructor` instances.

        Args:
            system_geometry(src.data_mng.gnss.geometry.SystemGeometry): instance of `SystemGeometry` to be used in the
                reconstruction models
            metadata(dict): dictionary with metadata information about the user configurations and models (generated by
                the :py:class:`src.modules.gnss.solver.gnss_solver.GnssSolver` instance)
            state(src.data_mng.gnss.state_space.GnssStateSpace): current GNSS State
            trace_data(tuple or None): path to the trace dir and iteration number
        """
        if trace_data is not None:
            trace_file = f"{trace_data[0]}\\RangeRateReconstructionIter_{trace_data[1]}.txt"
        else:
            trace_file = None
        super().__init__(system_geometry, metadata, state, trace_file)

    def compute(self, sat, epoch, datatype):
        """
        Reconstruct the pseudorange rate observation (in units of m/s).

        The pseudorange rate model is:
            PR_Rate = (v^sat - v_rec).los_cor + c(clock_rate_rec - clock_rate_sat - rel_clock_rate_sat)

        However, the receiver quantities `v_rec` and `clock_rate_rec` are excluded from the computations, because they
        are directly estimated in the Velocity Estimation Least-Squares.
        Note that since the pseudorange rate equation is linear with respect to `v_rec`, no linearization is required,
        hence the LS procedure estimates the complete `v_rec` and not a corrective (delta) quantity.
        """
        sat_clocks = self._system_geometry.sat_clocks
        time_emission = self._system_geometry.get("time_emission", sat)

        # fetch satellite velocity and clock drift
        v_sat = self._system_geometry.get("satellite_velocity", sat)
        _, clock_rate_sat = sat_clocks.get_clock(sat, time_emission)

        # correct satellite clock drift for relativistic corrections
        rel_clock_rate_sat = 0.0
        if self._metadata["REL_CORRECTION"] == EnumOnOff.ENABLED:
            rel_clock_rate_sat = self._system_geometry.get("drift_rel_correction", sat)

        # fetch user velocity and clock drift
        # v_rec = self._state.velocity + np.cross(constants.EARTH_ANGULAR_RATE, self._state.position)
        # clock_rate_rec = self._state.clock_bias_rate

        # get corrected line of sight. See Eq. (21.28) of [1]
        los = self.get_unit_line_of_sight(sat)
        los_cor = -1 * los / (1 + np.dot(v_sat, los) / constants.SPEED_OF_LIGHT)

        pr_rate = np.dot(v_sat, los_cor) + constants.SPEED_OF_LIGHT * (-clock_rate_sat - rel_clock_rate_sat)

        if self._write_trace:
            self._trace_handler.write(f"{epoch},{sat},{datatype},{pr_rate},{np.dot(v_sat, los_cor)},"
                                      f"{constants.SPEED_OF_LIGHT * (-clock_rate_sat - rel_clock_rate_sat)}\n")

        return float(pr_rate)
